# 征服C指针

#### Author： 前桥和弥
***

## Chap 0: 引言

* 导致混乱理解的一个幕后黑手是，数组和指针之间微妙的兼容性。
* c中**不存在**多维数组。

## Chap 1: 从基础开始
* 提高编译器的警告级别，不要无视编译器警告。
* 几乎所有C语言的实现中，运行时的检查总是不充分的。

c语言设计者优先考虑的问题是：
* 如何简单实现编译器；
* 如何让程序员写出高效率执行的程序。

安全问题就被忽略了。<br>
#### C 是只能使用标量的语言
早期的C语言**一度只能使用标量**：<br>
```c
if(str == 'abc')
```
这个表达式无法比较字符串是否相等，**只是在比较指针** .
### 关于指针
#### 指针究竟是什么？
**指针类型**并不单独存在，其实是由其他类型派生出来的。之后就有了“指针类型的变量”和“指针类型的值”（具体指的是**内存的地址**）。同时，变量**不一定**按照声明的顺序保存在地址中。<br>
**为什么用不同类型的指针** 在大部分运行时环境中，"指向int的指针"和"指向double的指针“在运行时是相同的事物，但是int和double的**内部表示完全不同**。在指针运算中，type就显得十分重要。<br>
#### 指针运算
对指针加N，指针前进当前指针指向的数据类型的长度 $\times$ N .
#### 空指针
空指针是确保没有指向任何一个对象的指针，用宏NULL来表示该常量`#define NULL（(void*) 0)`,通常作为函数发生异常时候的返回值。 一旦解引用NULL指针，就会被操作系统强行终止程序。

### 关于数组
数组是将固定个数、相同类型的变量排列起来的对象，在C中array的数据是连续排列的。<br>
**指针和数组** 给指针加N,指针前进 `sizeof(array[0])` $\times$ N, 但是无论写成pi++还是`*（pi+i）`,都不是很好理解，因此习惯使用[ ].在本书中，主张利用指针运算的写法不利于阅读，因此 **抛弃这种写法** .
#### 下标运算符

```c
p = &array[0];
p = array;
```

也就是说，`*(p + i)` 和`p[i]`是同样的意思,无论加不加[ ],array都可以理解成指针，在语法上，表达式中数组**下标运算符[]和数组无关**.只是方便读写才引入的[ ]运算符。<br>

#### 为什么有奇怪的指针运算

- 受到的祖先B语言的影响
- 早先使用指针运算可以写出高效率的程序

#### 不要滥用指针运算

一般情况下，使用指针的效率比较高是K&R C 时代的事情，现在的情况是两者几乎生成一样的代码，对于这种微不足道的优化，不如交给编译器做。