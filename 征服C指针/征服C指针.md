# 征服C指针

#### Author： 前桥和弥

## Chap 0: 引言

* 导致混乱理解的一个幕后黑手是，数组和指针之间微妙的兼容性。
* c中**不存在**多维数组。

## Chap 1: 从基础开始
* 提高编译器的警告级别，不要无视编译器警告。
* 几乎所有C语言的实现中，运行时的检查总是不充分的。

c语言设计者优先考虑的问题是：
* 如何简单实现编译器；
* 如何让程序员写出高效率执行的程序。

安全问题就被忽略了。<br>
#### C 是只能使用标量的语言
早期的C语言**一度只能使用标量**：<br>
```c
if(str == 'abc')
```
这个表达式无法比较字符串是否相等，**只是在比较指针** .
### 关于指针
#### 指针究竟是什么？
**指针类型**并不单独存在，其实是由其他类型派生出来的。之后就有了“指针类型的变量”和“指针类型的值”（具体指的是**内存的地址**）。同时，变量**不一定**按照声明的顺序保存在地址中。<br>
**为什么用不同类型的指针** 在大部分运行时环境中，"指向int的指针"和"指向double的指针“在运行时是相同的事物，但是int和double的**内部表示完全不同**。在指针运算中，type就显得十分重要。<br>
#### 指针运算
对指针加N，指针前进当前指针指向的数据类型的长度 $\times$ N .
#### 空指针
空指针是确保没有指向任何一个对象的指针，用宏NULL来表示该常量`#define NULL（(void*) 0)`,通常作为函数发生异常时候的返回值。 一旦解引用NULL指针，就会被操作系统强行终止程序。

### 关于数组
数组是将固定个数、相同类型的变量排列起来的对象，在C中array的数据是连续排列的。<br>
**指针和数组** 给指针加N,指针前进 `sizeof(array[0])` $\times$ N, 但是无论写成pi++还是`*（pi+i）`,都不是很好理解，因此习惯使用[ ].在本书中，主张利用指针运算的写法不利于阅读，因此 **抛弃这种写法** .
#### 下标运算符

```c
p = &array[0];
p = array;
```

也就是说，`*(p + i)` 和`p[i]`是同样的意思,无论加不加[ ],array都可以理解成指针，在语法上，表达式中数组**下标运算符[]和数组无关**.只是方便读写才引入的[ ]运算符。<br>

#### 为什么有奇怪的指针运算

- 受到的祖先B语言的影响
- 早先使用指针运算可以写出高效率的程序

#### 不要滥用指针运算

一般情况下，使用指针的效率比较高是K&R C 时代的事情，现在的情况是两者几乎生成一样的代码，对于这种微不足道的优化，不如交给编译器做。

#### 数组作为函数的参数进行传递

如果需要将数组作为函数参数进行传递,那就传入指向初始元素的指针和数组的size. 如果实在要pass-by-value, 建议将数组整理成结构体的成员.
在声明函数形参数时候, 数组的声明可以解读成指针.
```C
int func(int *a);
int func(int a[]); // 编译器解读成上面的形式
int func(int a[10]); // 元素个数会被编译器无视
int func(int *a, size_t nums); // 习惯把大小同时传入
```

## Chap 2 C 是怎样使用内存的

当今的操作系统会给应用程序的**每一个进程分配独立的**虚拟地址空间,同时还会对每一个内存区域设定"只读"或者"可读写"属性,也就是说, 程序面对的是虚拟地址空间.在C语言中, 有三种不同的变量寿命:
* 静态变量(包括全局变量和static声明的变量), 从程序运行时候开始,到程序关闭时结束
* 自动变量,从声明语句开始, 到所在的语句块执行结束为止
* malloc动态分配的变量, 寿命直到调用free为止

通过观察发现, 指向函数的指针和字符串常量被配置在非常近的内存区域, 函数内的static变量和全局变量这种静态变量也在非常近的区域, 接下来是`malloc()`动态分配的变量, 自动变量和他们距离都非常远, 这是因为如今大多数操作系统都将函数自身和字符串常量汇总配置在一个**只读内存区域**.<br>

### 指向函数的指针
```C
int (*func_p)(double); //声明一个指向函数的指针, 指向的函数接受一个double输出, 输出一个int
int (*func_table[])(double)={//由function pointer 构成的数组
    func0,
    func1,
    func2,
};
```
### 静态变量
全局变量, 文件内的static和指定static的局部变量都是静态变量, 对于函数的全局变量, 如果有相同的名称, 即使跨越多个源代码文件也是被当做同一个对象对待, 进行这项工作的就是链接器, 为了将名称结合起来, 各目标代码大多具备一份**符号表**,在unix系统中, cc -c *.c, nm *.o就可以看到符号表具体的内容,它将不同的变量赋予了不同的tag方便链接过程.

### 自动变量

自动变量使用重复的内存区域, 使用结束后回将内存归还, 在C语言中,**一般将自动变量存放在栈中**.函数调用过程也和栈相关, 函数调用结束后局部变量所占用的内存区域就被释放, 调用函数过程中的传值一般就是传递实参的副本,