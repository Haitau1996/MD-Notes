# Using The C++ Standard Template Libraries
**Ivor Hortan**
***

## Chap 1: intruction to STL
STL为一个功能强大且可扩展的工具集,用于组织和处理数据,STL可以划分为四个概念库:

1. 容器库
2. 迭代器库
3. 算法库
4. 数值库

### 模板
__模板并不是可执行的代码, 而是用于生成代码的蓝图或者配方__.在程序中, 如果一个模板从来没有被实例化过, 那么它将被编译器忽略.当模板的实例化类型存在歧义的时候, 可以显式指定消除多义性.(一般而言, 定义类模板的时候喝定义其他类一样, 需要拷贝构造,移动构造,拷贝赋值运算符,移动赋值运算符以及析构函数五个成员)<br>
类的模板类型参数需要一个实参,除非有默认实参.实例化一个模板的时候, 发生了三个事情:
1. 确定了参数类型
2. 生成了构造函数的定义
3. 析构函数也被生成用来销毁对象

### 容器
STL 提供了下面的三种容器:
1. 顺序容器: 用线性的方式组织对象, 但是可能不需要连续的存储空间
2. 关联容器: 可以用 key 去得到对应的 value
3. 容器适配器: 提供了替换机制的适配器模板, 可以用来访问基础的序列容器或者关联容器

__容器在堆上存放对象__,并且自动管理他们所占用的内存. 默认的内存分配器(allocator)性能还是不错的, 在这里不讨论自定义的内存分配器相关的话题.<br>

### 迭代器
是一种类似于指针的模板类对象, 使用STL算法的时候, 迭代器将容器和算法联系在了一起, 通常使用一对迭代器表示一段数据(from begin to end),通常使用 _c.begin() / c.end()_ 或者 _std::begin(c) / std::end(c)_ 得到对象的两个典型迭代器. 
#### 迭代器的类别
所有类型的迭代器都必须要有一个拷贝构造函数, 一个析构函数以及一个拷贝赋值运算符. 而迭代器指向的对象必须是可交换的(swappable).
1. 输入迭代器:提供对象的可读访问
2. 输出迭代器: 提供对象的只写访问
3. 正向迭代器: 结合了输入迭代器输出迭代器的功能
4. 双向迭代器: 在前者基础上增加了自减运算
5. 随机访问迭代器: 可以支持对元素的随机访问. 这意味着它支持以下操作:
   * 通过一个整数进行自增/自减 `iter+=n`, `iter-=n`...
   * 通过一个整数进行索引访问 `iter[n]` 意思是 `*(iter+n)`
   * 两个迭代器之间做差得到迭代器之间元素个数
   * 迭代器可以进行大小比较

这些迭代器之间通过 `iterator_tag`(traits)标识, 可以通过它来指定算法的参数, 表明他们满足算法需要的最小条件. 
#### 流迭代器
可以使用流迭代器, **在流和可以通过迭代器访问的数据之间参数文本模式的数据**. STL 算法可以通过指定一对迭代器来输入数据, 所有对于任何可以通过输入流访问的数据源, 都可以将算法运用到他们的元素上, 例如算法, 可以像运用到容器中的对象上那样运用到流中的对象上. 可以创建流迭代器对象, 来处理指定类型的流对象数据. `istream_iterator<T>` 这个输入流迭代器, 可以从文件流或者标准输入流`cin`, 输出流迭代器为对象提供了一个向输出流输出的功能. 下面这段代码就通过 accumulate() 函数, 计算 `cin` 流迭代器输入的一些数据的和:
```C++
std::cout << "\nThe sum of the values you entered is "
    << std::accumulate(std::istream_iterator<double>(std::cin),
    std::istream_iterator<double>(), 0.0)
    << std::endl;
```
#### 迭代器适配器
这是一个类模板, 为标准的迭代器提供了一些特殊的行为, 使得他们能够从迭代器模板得到派生, 下面分别介绍这三种适配器模板.
##### 反向迭代器
工作机制和标准迭代器相反, 可以创建双向或者随机访问迭代器的反向迭代器:<br>
![](figure/1.1.png)<br>
容器元素的反向迭代器相对于标准迭代器, 向左偏移了一个 Object. 每个反向迭代器都有一个成员函数 `base()`, 返回一个基础迭代器, 指向 rIter 的下一个位置:<br>
![](figure/1.2.png)<br>
##### 插入迭代器
一般的迭代器只能访问或者改变序列中存在的元素, **插入迭代器通常用于在容器的任何位置添加新的元素, 不能作用在`array<T,n>`这种 fixed-size 容器上**:
* 向后插入迭代器: 通过调用成员函数`push_back()` 将一个新的元素添加到容器的尾部, 如果容器没有定义 `push_back()` 函数,向后插入迭代器将无法使用(`vector, list, deque` 都有这个函数)
* 向前插入迭代器: 通过调用成员函数`push_front()`, 将新元素添加到容器的头部, 同样的没有定义这种函数的话就无法使用(`list, forward_list, deque` 都有)
* 插入迭代器: 用于向任何有 `insert()` 函数的容器插入一个新的元素

##### 移动迭代器
