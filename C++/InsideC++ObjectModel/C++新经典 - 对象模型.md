# C++ 新经典: 对象模型
## Chap 1: Visual Studio 常见快捷方式
* `F9`: add/remove a break point in current line
* `F5`: 开始调试
* `F10`: 逐过程调试
* `F11`: 逐语句调试
* `Alt + 6`: 调试 -> 窗口 -> 内存 -> 内存1 `&some_var` （查看内存内容）
* `Shift + F9`: 调试 -> 快速监视

## Chap 2: 对象
### 空间占用
* 即使不包含任何成员的类， 在 sizeof operator 操作的结果依然是 1 而不是 0. **对象是有地址的， 在内存中对应的位置保存了 1 个字节的内容**。 
* **类中的成员函数是不占用类对象内存空间的**，（实际上是跟着类走， 和对象关系不大）
* 成员变量是在每个对象中，占用对象的空间

### 对象结构的发展和演化
当下主要的 C++ 对象模型如下：
1. 非静态的成员变量跟着对象走
2. 静态成员变量跟对象没有关系
3. 静态、非静态的成员函数都保存在类对象实例外
4. 虚函数是通过在类对象中添加一个指向虚函数表的指针实现

如果类之间有多重的继承关系， 并且每个父类都有虚函数， 那么子类的情况可能有所不同。  

### `this` 指针
<div align=center><img src="https://i.imgur.com/7LTXVcd.png"  width="40%" height="40%"/></div><div align=center><img src="https://i.imgur.com/lPUFBkC.png"/></div>

我们使用一个 [C 类的对象](code/2.this_in_multi_inheritance.cpp)调用三个函数， 发现 A 和 C 的 this 指针指向同一个位置而 B 则和他们相差一个 sizeof(int):<div align=center><img src="https://i.imgur.com/Zn6l0PX.png"/></div>


这是因为 C 对象有三个部分， 从 A B继承的和本身， 而先从 A 类继承因此 AC 都是从那个地方开始， 而 B 对象则是在中间部分。如果 C 中 override 了 funcB[^overrideFuncB]， 那么调用 c.funcB 结果会是 004FF8F4:
[^overrideFuncB]: override non-virtual 实际上是一个非常不好的做法，因为override 一般是要实现动态绑定， 而 non-virtual 是静态绑定
```C++
c_obj.funcB();// 004FF8E4
c_obj.B::funcB();//004FF8E8
```

### 构造函数
程序员如果没有定义任何构造函数， 编译器会隐式地生成一个默认的构造函数，但是实际上==只有在必要的时候编译器才会合成默认构造函数， 而不是必然或者必须合成==, 我们有俩面两个类：
<div align=center><img src="https://i.imgur.com/VSDahJ0.jpg"/></div>

在 [mian 函数](code/2.default_ctor.cpp)中加入 `Obj_with_ctor obj1;` 和 `Obj_without_ctor obj2`, 再使用
```shell
g++  -Og -S 2.default_ctor.cpp 
```
可以得到汇编文件，从中查看可以发现， 及时我们使用
1. 该类没有任何构造函数， 但**包含一个类类型的成员变量,同时该成员所属的类有一个默认的构造函数**， 例如下面的结构中，编译器就会为`ClassWithoutCtor`生成默认的构造函数， 同时在该构造函数中会调用数据成员的默认构造函数。 此外如果有多个数据成员对象并且所属类有默认构造函数， 那么调用构造函数顺序和声明他们的顺序一致。<div align=center><img src="https://i.imgur.com/ODdPBjC.png"/></div>
2. 父类带有默认构造函数，子类没有任何构造函数<div align=center><img src="https://i.imgur.com/SCTPvAx.png"/></div>
3. 类有虚函数， 并且没有任何构造函数： 因为虚函数的存在， 编译器为该类生成一个虚函数表， 在其中记录各个虚函数的地址。 而该构造函数做的事情就是把类的虚函数表地址赋给类的虚函数表指针（因为每个对象都有一个虚指针， 而实际的虚函数表只有一个）。 就算我们实现了构造函数， 编译器依旧会帮我们把虚函数表赋值的必要过程安插进去
4. 如果一个类带有虚基类， 编译器也会为子类和父类都生成“合成默认构造函数”, 在下面的虚继承结构中， Grand 类被继承了两次， 因此在 Object 中有两个 Grand 子类对象， 引入虚继承后， 无论 Grand 类在结构中出现了多少次，  Object 中只有一个 Grand 子对象。<div align=center><img src="https://i.imgur.com/h8ekHqu.png"/></div>
5. 类中有成员变量在定义时赋初值`private: int val{0};`

### 拷贝构造和移动构造
当我们用一个类对象初始化该类的另一个对象时候， 要调用类的拷贝构造函数。 在程序员没有定义自己的拷贝构造函数时， 编译器会在<font color=red>必要的时候</font> 合成一个拷贝构造函数。<div align=center><img src="https://i.imgur.com/OApuEWG.png"/></div>
在上面的类中没有自定义的拷贝构造函数， 编译器也不会生成一个。 因为对于简单类型的成员变量， 直接按值拷贝， 编译器无需合成拷贝构造函数就可以轻松实现这点。<div align=center><img src="https://i.imgur.com/FEFFEMR.png"/></div>
就算 A 中有一个类类型的成员变量， 编译器也可以递归式地去直接复制数据， 而不是合成拷贝构造函数。编译器会在下面的情况中合成拷贝构造函数：
1. 一个类 A 没有拷贝构造函数， 但是类内包含了一个类类型的成员变量， 而该成员变量有拷贝构造函数
2. 一个类没有拷贝构造函数， 但是它继承自一个有拷贝构造函数的父类
3. 一个类没有拷贝构造函数， 但是该类定义了虚函数或者继承了定义了虚函数的父类
4. 一个类没有拷贝构造函数， 但是该类含有虚基类

同样的， 如果类中的赋值运算符没有被程序员重载， 在某些情况下编译器就会为该类重载赋值运算符。  
C++11 引入了移动构造和移动赋值两个概念。
1. 如果一个类定义了 big-3 中的任意一个， 说明程序员有自己复制和释放对象的倾向， 编译器不会自动生生成移动相关的函数
2. 只有类中没有自己版本的 big-3 且每个非静态成员都可以移动时， 编译器会为它合成
   1. 内置类型的成员变脸够可以移动
   2. 成员变量是一个类类型， 并且这个类有移动相关的函数， 则该变量可以移动

### 程序转换
程序转换就是程序员书写的代码会被编译器拆分成更容易被理解和实现的代码。 
在定义对象`C c1 = c0`的时候， 从编译器的视角来看是两个步骤：
1. 定义一个对象， 为对象分配内存`C c1;`
2. 调用对象的拷贝构造函数`c1.C::C(c0);`

实际编译器在处理的时候并不会调用它的默认构造函数， 所以我们只看到了拷贝构造函数被调用。  
如果我们使用传值的方式向函数传入参数， 编译器会在函数的栈空间内构造出一个 temp 对象， 然后离开前会析构它：
```c++
C temp;
temp.C::C(c0);
func(temp);
temp.C::~C();
```
因此我们用引用传递的方式可以节约对象的构造和析构过程的成本。编译器还会做一种被称为 RVO 的优化， 就是在函数的调用端直接构造所调用的函数返回的对象。  

### 程序的优化
从开发者层面， 我们有一个包含两个 int 数据的类 TempValue, 为它写一个 double 函数：
```c++
TempValue double(TempValue& ts){// 使用 reference，减少对象拷贝
    TempValue temp;
    temp.first = ts.first * 2;
    temp.second = ts.second * 2;
    return temp;
}
```
在 msvc 中发现，调用端中即使函数没有接收者， 依然有一个构造函数的析构函数的消耗， 我们可以直接把函数体改为：
```c++
return TempValue(ts.first*2, ts.second*2);
```
实际上 g++ 中我们写第一个版本的函数， 编译器会帮助我们优化， 可以适用 `-fno-elide-constructors` 关闭这个优化选项。而在 C++ 中将优化选项改为 /O2, 然后将运行时检查改为默认， 就可以优化成后者的结果。  

### 拷贝构造函数与深浅拷贝
<div align=center><img src="https://i.imgur.com/sdshN4x.png"/></div>

```C++
X x1(1000);
X x2 = 1000;
X x3 = X(1000);
x x4 = (X)1000;
```
在上面的 X 类中， 如果打开编译器优化， 看起来都是一样的， 如果使用`-fno-elide-constructors` 我们可以发现后面三种做法都生成了一个临时变量,多了一个临时变量的构造和析构成本：
```C++
// 第一种
X x1;
x1.X::X(1000);
// 后三种
X _temp;
_temp.X::X(1000);
X x2;
x2.X::X(_temp);
_temp.X::~X();
```

如果类内部全是基本类型的成员变量， 那么拷贝构造函数作用不大， 因为编译器本身就支持 bitwise 拷贝。处理很复杂的成员变量类型的时候， 如类中包含指针作为成员变量， 就使得原来的复制能力失效，==程序员在类中增加了复制构造函数之后， 就要对类中的各个成员变量的初始化负责==。  
这时候就有深浅拷贝的问题， 如果没有自定义的复制构造函数， 对于指针的拷贝容易使得析构函数对指针的 double free 问题。这时候需要在复制构造函数中实现深拷贝:
```c++
X(const X& temp){
    p_mi = new int(100);
    memcpy(p_mi, temp.p_mi, sizeof(int));
    m_i = temp.m_i;
}
```

### 成员初始化列表
除开效率因素， 在[一些场合](code/2.menber_ini_list_example.cpp)下必须使用成员初始化列表：
1. 成员变量是引用类型
2. 成员变量的类型是 const
3. 类继承自一个基类， 并且基类中有构造函数并且构造函数中有参数
4. 类成员变量是某个类型， 而且构造函数带参数

使用成员初始化列表的原因就是<font color=red>提高程序的运行效率</font>,如果不用的， 执行构造函数的函数体之前就构造了一个对象，然后再给其中赋值， 往往会影响效率。在作几点声明：
1. 初始化列表中的代码可以看作被编译器安插在构造函数中的
2. 初始化列表中的代码在构造函数的函数体执行之前就被执行
3. 列表中变量的初始化顺序和**类之间定义的顺序相同**，而不是和初始化列表中出现的顺序一致（最好是两者顺序相同，避免误导）  

## Chap 3: 虚函数
如果一个类有虚函数， 针对该类产生一个虚函数表， 生成该类的对象的时候， 对象里就会有一个指针（虚指针）指向虚函数的起始地址， 这个指针可以看成是类中的一个成员变量， 其位置可能在对象的开头或者末尾。<div align=center><img src="https://i.imgur.com/vOlNYGT.png"/></div>

此外， 虚函数是可以手动调用的， 在上面的继承结构（所有函数都是虚函数）中，我们可以将 Derived 对象的地址转为 `long*`(验证过虚指针放在开头)， 它指向的位置起始就是虚函数表：
```c++
Derived* d = new Derived();
long* pvptr = (long*)d;
long* vptr = (long*)(*pvptr); // 访问虚指针指向的位置， 起始就是虚函数表
typedef void(*Func)(void);
Func f = (Func)vptr[0];
f();
```
上面的过程就是通过函数指针去调用虚函数。实际上它们在内存中的示意图如下：
<div align=center><img src="https://i.imgur.com/jXmgc3i.jpg"width="40%"/></div> 

1. 包含虚函数的类才会有虚函数表， 同属于一个类的对象共享，但是每个对象都有 vptr
2. 父类有虚函数等于子类也有虚函数， 而且但继承下是一个虚函数表
3. 子类没有新的虚函数的话， 其则两者的表内容相同， 但在内存中依旧是两张表而不是同一张
4. 虚函数表越界后的行为是未定义的

然后我们考察 derived 的对象赋值给 base 类， 发现通过新的对象调用的虚函数依旧是 base 类的， `Derived d;Base b = d;`中的后面一句做了两个事情：
1. 生成一个 base 对象 b
2. 使用 d 对象来初始化 b

因此， 这个过程除了会有对象裁切（超出 Base 类的成员变量被裁切掉）， 而初始化过程就是将 vptr 值指向 Base 的 vptr, 而不是直接复制 d 中的 vptr 地址。  

### 多重复合下虚函数表
<div align=center><img src="https://i.imgur.com/TEfACMn.png"/></div>

通过和上面类似的方法观察， 发现多继承下一个对象有多个包含虚函数的基类， 就会有多个虚函数表指针，各个 vptr 按照顺序放在内存空间中， 并且子类和第一个基类共用一个虚函数表指针,下图是 msvc 输出结果的一个示意图。<div align=center><img src="https://i.imgur.com/GkeuKFn.jpg" width="60%"/></div>

而虚函数表地址赋值给对象的vptr的语句， 是编译时候会往类的构造函数安插的， 实际上编译期间就为每个类确定好了对应虚函数表的内容。 [CSAPP](../../ComputerSystem/CSAPP/CSAPP.Mooc.md#lecture-13-linking) Lecture 13 中介绍了执行程序。如果我们将一个带有虚函数的类构造函数重新写成下面的形式：
```c++
X() {
	memset(this, 0, sizeof(X));
}	
X(const X& temp) {
	memcpy(this, &temp, sizeof(X));
}
// in main function
X x1;
x1.virtual_func();
x1.normal_func();
X* ptrX = new X();
ptrX->virtual_func(); //errorMessage: 引发异常， 读取访问权限冲突， ptrX-> 是 nullptr
ptrX->normal_func();// OK
```
这个现象出现的原因是， 函数地址起始是没有变的， 通过指针去访问虚函数， 做的是动态绑定， 需要查看虚函数表的信息， 而普通函数或者**通过对象去调用虚函数是静态绑定， 在编译的时候就可以将语句和函数的地址绑定在一起**， 因此用不到虚函数表， 使用 menset 将虚函数表指针清零并不影响函数调用。  
实际上虚函数和多态是给指针和引用使用的， 对象调用虚函数做的也是静态绑定。  

## Chap 4: 数据语义学
