# C++ 设计模式
## Lec 1: Intro
课程目标:
* 理解松耦合设计思想
* 掌握面向对象的设计原则
* 掌握重构激发改善设计
* 掌握 GoF 核心设计模式

> 每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动。

可复用是我们的设计目标, 面向对象是我们具体使用的方法. OO 涉及编程中常见的抽象思维,帮助我们很好地管理代码的复杂度:<div align=center><img src="https://i.imgur.com/ECexQDt.png"/></div>

OO 向下主要有三种机制:
* 封装: 如何隐藏内部实现
* 继承: 复用现有的代码
* 多态: 改写对象的行为

而向上需要掌握==什么是好的面向对象设计==.

我们解决复杂性有两种常见的做法:
* 分解: 将大问题分解成多个小问题, 复杂问题分解为多个简单问题(结构化编程时候常用)
* ==抽象==: 由于不能掌握全部的的复杂对象，我们选择忽视它的非本质细节，而去处理泛化和理想化了的对象模型。

## Lec 2: 面向对象的设计原则
变化是复用的天敌, ==面向对象设计的最大优势在于抵御变化==.
* 理解隔离变化
  * 从宏观层面来看，面向对象的构建方式更能适应软件的变化，能将变化所带来的影响减为最小
* 各司其职
  * 从微观层面来看，==面向对象的方式更强调各个类的“责任”==
  * 由于需求变化导致的新增类型不应该影响原来类型的实现——是所谓各负其责
* 对象是什么
  * 从语言实现层面来看，对象封装了代码和数据
  * 从规格层面讲，对象是一系列可被使用的公共接口
  * 从概念层面讲，对象是某种==拥有责任的抽象==

### 面向对象的设计原则
* ==依赖倒置原则==(DIP)
  * 高层模块(==稳定==)不应该依赖于低层模块(==变化==)，二者都应该依赖于抽象(==稳定==) 。
  * 抽象(稳定)不应该依赖于实现细节(变化) ，实现细节应该依赖于抽象(稳定)。<div align=center><img src="https://i.imgur.com/26kay53.png"/></div>
* 开放封闭原则（OCP）
  * 对扩展开放，对更改封闭
  * 类模块应该是可扩展的，但是不可修改
* 单一职责原则（SRP）
  * 一个类应该仅有一个引起它变化的原因。
  * 变化的方向==隐含着类的责任==(多个责任把类往不同的方向拉扯)
* Liskov 替换原则（LSP）
  * 子类必须能够替换它们的基类(IS-A)
  * 继承表达类型抽象
* 接口隔离原则(ISP)
  * 接口应该小而完备
  * 不应该强迫客户程序依赖它们不用的方法
* 优先使用对象组合，而不是类继承
  * 继承关系更像是类属关系而不是父子关系
  * 继承在某种程度上破坏了封装性，==子类父类耦合度高==。
  * 而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。
* 封装变化点
  * 使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。
* 针对接口编程，而不是针对实现编程(和 DIP 相辅相成, 从不同角度看同一个问题)
  * 不将变量类型声明为某个特定的具体类，而是声明为某个接口
  * 客户程序无需获知对象的具体类型，只需要知道对象所具有的接口
  * 减少系统中各部分的依赖关系，从而实现“高内聚、松耦合”的类型设计方案。

## 组件协作模式
GoF 中 23 种模式的分类:
* 从目的来看：
  * 创建型（Creational）模式：将对象的部分创建工作延迟到子类或者其他对象，从而应对需求变化为对象创建时具体类型实现引来的冲击。
  * 结构型（Structural）模式：通过类继承或者对象组合获得更灵活的结构，从而应对需求变化为对象的结构带来的冲击。
  * 行为型（Behavioral）模式：通过类继承或者对象组合来划分类与对象间的职责，从而应对需求变化为多个交互的对象带来的冲击。
* 从范围看:
  * 类模式处理类与子类的静态关系: 偏向于继承方案
  * 对象模式处理对象间的动态关系: 偏向于组合模式
* 从封装变化的角度看<div align=center><img src="https://i.imgur.com/CKfgJmV.png"/></div>

学习设计模式的重要方法是由重构获得模式:
* 面向对象设计模式是“好的面向对象设计”，所谓“好的面向对象设计”指是那些可以满足“==应对变化，提高复用==”的设计
* 现代软件设计的特征是“需求的频繁变化”。设计模式的要点是 “==寻找变化点，然后在变化点处应用设计模式，从而来更好地应对需求的变化==”.“什么时候、什么地点应用设计模式”比“理解设计模式结构本身”更为重要。
* 设计模式的应用不宜先入为主，没有一步到位的设计模式。敏捷软件开发实践提倡的 “Refactoring to Patterns” 是目前普遍公认的最好的使用设计模式的方法。

重构有很多关键的技法:他们其实是从不同的角度看待同一个问题
* 静态 -> 动态
* 早绑定 -> 晚绑定
* 继承 -> 组合
* 编译时依赖 -> 运行时依赖
* 紧耦合 -> 松耦合

现代软件专业分工之后的第一个结果是 “框架与应用程序的划分”，“组件协作”模式通过==晚期绑定==，来实现 **框架与应用程序之间的松耦合**，是二者之间协作时常用的模式。
* Template Method
* Observer / Event
* Strategy

### Template Method
#### 动机
* 在软件构建过程中，对于某一项任务，它常常有==稳定的整体操作结构==，但各个子步骤却有很多==改变的需求==，或者由于固有的原因（比如框架与应用之间的关系）而无法和任务的整体结构同时实现
* 如何在确定稳定操作结构的前提下，来灵活应对各个子步骤的变化或者晚期实现需求？

<div align=center><img src="https://i.imgur.com/h5f3t13.png"/></div>
<div align=center><img src="https://i.imgur.com/IMxf5nR.png"/></div>

可以看到, 第一种是早绑定的方法, 晚实现的 Application 调用早实现的 Library, 是一种早绑定的方法, 而下面的刚好相反.<div align=center><img src="https://i.imgur.com/VdabRuf.png"/></div>

#### 定义
> 定义一个操作中的算法的骨架(**稳定**)，而将一些步骤**延迟(变化)到子类中**。Template Method使得子类可以不改变(**复用**)一个算法的结构即可重定义(override 重写)该算法的某些特定步骤。

延迟到子类一般而言就是定义一个虚函数, 让子类去实现它们.  
在使用设计模式的时候, 我们需要能够区分哪些部分是稳定的哪些部分是变化的, 如上面就认为程序的主流程结构是相对稳定的, 更具有复用价值.

#### 结构
<div align=center><img src="https://i.imgur.com/fBirMns.png"/></div>

上面的结构中, 红色部分是稳定的, 而蓝色部分是变化的.

#### 要点总结
* Template Method模式它用最简洁的机制（虚函数的多态性）为很多应用程序框架提供了灵活的扩展点(扩展一般指的就是继承+多态)
* Template Method 有典型的“不要调用我，让我来调用你”的反向控制结构。(C++利用虚函数的晚绑定机制, 其他语言中的晚绑定不一定为虚函数)
* 被Template Method调用的虚方法可以具有实现，也可以没有任何实现（抽象方法、纯虚方法），但一般推荐将它们设置为protected方法(一般不供外界调用)。

### 策略模式
#### 动机
* 在软件构建过程中，某些对象使用的算法(广义的)可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常复杂；而且有时候支持不使用的算法也是一个性能负担。
* 如何在运行时根据需要透明地更改对象的算法？将算法与对象本身解耦，从而避免上述问题？

需要注意的是, 我们在设计软件的时候需要做动态的考虑, 加上一个时间轴, 将来极可能会发生哪些变化.如[这里](code/strategy_before_refactoring.cpp)一个税务系统, 将来可能需要增加新的国家,这时候需要改枚举类型, 同时加入另一个 else if 分支.  
我们可以考虑新建一个基类, 其中包含计算税率的纯虚函数.[这时候](code/strategy_after_refactoring.cpp)一个一个的算法就变成了一个一个子类, 放在时间轴上考虑, 增加新的做法的时候执只要新增一个子类继承基类, SalesOrder 就不需要变化.这就可以实现二进制单位意义的复用, 而不是源代码的复用,满足了开闭原则.

#### 模式定义
定义一系列算法，把它们一个个封装起来(使用类封装)，并且使它们可互相替换（变化, 基类的多态调用实现）。该模式使得算法可独立于使用它的客户程序(稳定)而变化（扩展，子类化）。

#### 结构
<div align=center><img src="https://i.imgur.com/2btPNP0.png"/></div>

#### 要点总结
* Strategy及其子类为组件提供了一系列可重用的算法，从而可以使得类型在 ==运行时==(多态调用)方便地根据需要在各个算法之间进行切换。
* Strategy模式 ==提供了用条件判断语句以外的另一种选择，消除条件判断语句，就是在解耦合==。(if-else 是结构化时候的分而治之的思维, 在 OO 中其实不太好, 而且未来可能有多种情况, if-eles 可能有绝对不变的情况, 如一周七天, 这中情况下可以用)
* 如果 Strategy 对象没有实例变量，那么各个上下文可以共享同一个 Strategy 对象(单例模式)，从而节省对象开销。