<font size=10> C++ 设计模式</font>

- [Lec 1: Intro](#lec-1-intro)
- [Lec 2: 面向对象的设计原则](#lec-2-面向对象的设计原则)
  - [面向对象的设计原则](#面向对象的设计原则)
- [组件协作模式](#组件协作模式)
  - [Template Method](#template-method)
    - [动机](#动机)
    - [定义](#定义)
    - [结构](#结构)
    - [要点总结](#要点总结)
  - [策略模式](#策略模式)
    - [动机](#动机-1)
    - [定义](#定义-1)
    - [结构](#结构-1)
    - [要点总结](#要点总结-1)
  - [观察者模式](#观察者模式)
    - [动机](#动机-2)
    - [定义](#定义-2)
    - [结构](#结构-2)
    - [要点总结](#要点总结-2)
- [单一职责模式](#单一职责模式)
  - [装饰模式](#装饰模式)
    - [动机](#动机-3)
    - [定义](#定义-3)
    - [结构](#结构-3)
    - [要点总结](#要点总结-3)
  - [桥模式](#桥模式)
    - [动机](#动机-4)
    - [定义](#定义-4)
    - [结构](#结构-4)
    - [要点总结](#要点总结-4)
- [对象创建模式](#对象创建模式)
  - [工厂方法模式](#工厂方法模式)
    - [动机](#动机-5)
    - [定义](#定义-5)
    - [结构](#结构-5)
    - [要点总结](#要点总结-5)
  - [抽象工厂模式](#抽象工厂模式)
    - [动机](#动机-6)
    - [定义](#定义-6)
    - [结构](#结构-6)
    - [要点总结](#要点总结-6)
  - [原型模式](#原型模式)
    - [动机](#动机-7)
    - [定义](#定义-7)
    - [结构](#结构-7)
    - [要点总结](#要点总结-7)
  - [构建器模式](#构建器模式)
    - [动机](#动机-8)
    - [定义](#定义-8)
    - [结构](#结构-8)
    - [要点总结](#要点总结-8)
- [对象性能模式](#对象性能模式)
  - [单件模式](#单件模式)
    - [动机](#动机-9)
    - [定义](#定义-9)
    - [结构](#结构-9)
    - [要点总结](#要点总结-9)
  - [享元模式](#享元模式)
    - [动机](#动机-10)
    - [定义](#定义-10)
    - [结构](#结构-10)
    - [要点总结](#要点总结-10)
- [接口隔离模式](#接口隔离模式)
  - [façade 门面模式](#façade-门面模式)
    - [动机](#动机-11)
    - [定义](#定义-11)
    - [结构](#结构-11)
    - [要点总结](#要点总结-11)
  - [Proxy 代理模式](#proxy-代理模式)
    - [动机](#动机-12)
    - [定义](#定义-12)
    - [结构](#结构-12)
    - [要点总结](#要点总结-12)
  - [适配器](#适配器)
    - [动机](#动机-13)
    - [定义](#定义-13)
    - [结构](#结构-13)
    - [要点总结](#要点总结-13)
## Lec 1: Intro
课程目标:
* 理解松耦合设计思想
* 掌握面向对象的设计原则
* 掌握重构激发改善设计
* 掌握 GoF 核心设计模式

> 每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动。

可复用是我们的设计目标, 面向对象是我们具体使用的方法. OO 涉及编程中常见的抽象思维,帮助我们很好地管理代码的复杂度:<div align=center><img src="https://i.imgur.com/ECexQDt.png"/></div>

OO 向下主要有三种机制:
* 封装: 如何隐藏内部实现
* 继承: 复用现有的代码
* 多态: 改写对象的行为

而向上需要掌握==什么是好的面向对象设计==.

我们解决复杂性有两种常见的做法:
* 分解: 将大问题分解成多个小问题, 复杂问题分解为多个简单问题(结构化编程时候常用)
* ==抽象==: 由于不能掌握全部的的复杂对象，我们选择忽视它的非本质细节，而去处理泛化和理想化了的对象模型。

## Lec 2: 面向对象的设计原则
变化是复用的天敌, ==面向对象设计的最大优势在于抵御变化==.
* 理解隔离变化
  * 从宏观层面来看，面向对象的构建方式更能适应软件的变化，能将变化所带来的影响减为最小
* 各司其职
  * 从微观层面来看，==面向对象的方式更强调各个类的“责任”==
  * 由于需求变化导致的新增类型不应该影响原来类型的实现——是所谓各负其责
* 对象是什么
  * 从语言实现层面来看，对象封装了代码和数据
  * 从规格层面讲，对象是一系列可被使用的公共接口
  * 从概念层面讲，对象是某种==拥有责任的抽象==

### 面向对象的设计原则
* ==依赖倒置原则==(DIP)
  * 高层模块(==稳定==)不应该依赖于低层模块(==变化==)，二者都应该依赖于抽象(==稳定==) 。
  * 抽象(稳定)不应该依赖于实现细节(变化) ，实现细节应该依赖于抽象(稳定)。<div align=center><img src="https://i.imgur.com/26kay53.png"/></div>
* 开放封闭原则（OCP）
  * 对扩展开放，对更改封闭
  * 类模块应该是可扩展的，但是不可修改
* 单一职责原则（SRP）
  * 一个类应该仅有一个引起它变化的原因。
  * 变化的方向==隐含着类的责任==(多个责任把类往不同的方向拉扯)
* Liskov 替换原则（LSP）
  * 子类必须能够替换它们的基类(IS-A)
  * 继承表达类型抽象
* 接口隔离原则(ISP)
  * 接口应该小而完备
  * 不应该强迫客户程序依赖它们不用的方法
* 优先使用对象组合，而不是类继承
  * 继承关系更像是类属关系而不是父子关系
  * 继承在某种程度上破坏了封装性，==子类父类耦合度高==。
  * 而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。
* 封装变化点
  * 使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。
* 针对接口编程，而不是针对实现编程(和 DIP 相辅相成, 从不同角度看同一个问题)
  * 不将变量类型声明为某个特定的具体类，而是声明为某个接口
  * 客户程序无需获知对象的具体类型，只需要知道对象所具有的接口
  * 减少系统中各部分的依赖关系，从而实现“高内聚、松耦合”的类型设计方案。

## 组件协作模式
GoF 中 23 种模式的分类:
* 从目的来看：
  * 创建型（Creational）模式：将对象的部分创建工作延迟到子类或者其他对象，从而应对需求变化为对象创建时具体类型实现引来的冲击。
  * 结构型（Structural）模式：通过类继承或者对象组合获得更灵活的结构，从而应对需求变化为对象的结构带来的冲击。
  * 行为型（Behavioral）模式：通过类继承或者对象组合来划分类与对象间的职责，从而应对需求变化为多个交互的对象带来的冲击。
* 从范围看:
  * 类模式处理类与子类的静态关系: 偏向于继承方案
  * 对象模式处理对象间的动态关系: 偏向于组合模式
* 从封装变化的角度看<div align=center><img src="https://i.imgur.com/CKfgJmV.png"/></div>

学习设计模式的重要方法是由重构获得模式:
* 面向对象设计模式是“好的面向对象设计”，所谓“好的面向对象设计”指是那些可以满足“==应对变化，提高复用==”的设计
* 现代软件设计的特征是“需求的频繁变化”。设计模式的要点是 “==寻找变化点，然后在变化点处应用设计模式，从而来更好地应对需求的变化==”.“什么时候、什么地点应用设计模式”比“理解设计模式结构本身”更为重要。
* 设计模式的应用不宜先入为主，没有一步到位的设计模式。敏捷软件开发实践提倡的 “Refactoring to Patterns” 是目前普遍公认的最好的使用设计模式的方法。

重构有很多关键的技法:他们其实是从不同的角度看待同一个问题
* 静态 -> 动态
* 早绑定 -> 晚绑定
* 继承 -> 组合
* 编译时依赖 -> 运行时依赖
* 紧耦合 -> 松耦合

现代软件专业分工之后的第一个结果是 “框架与应用程序的划分”，“组件协作”模式通过==晚期绑定==，来实现 **框架与应用程序之间的松耦合**，是二者之间协作时常用的模式。
* Template Method
* Observer / Event
* Strategy

### Template Method
#### 动机
* 在软件构建过程中，对于某一项任务，它常常有==稳定的整体操作结构==，但各个子步骤却有很多==改变的需求==，或者由于固有的原因（比如框架与应用之间的关系）而无法和任务的整体结构同时实现
* 如何在确定稳定操作结构的前提下，来灵活应对各个子步骤的变化或者晚期实现需求？

<div align=center><img src="https://i.imgur.com/h5f3t13.png"/></div>
<div align=center><img src="https://i.imgur.com/IMxf5nR.png"/></div>

可以看到, 第一种是早绑定的方法, 晚实现的 Application 调用早实现的 Library, 是一种早绑定的方法, 而下面的刚好相反.<div align=center><img src="https://i.imgur.com/VdabRuf.png"/></div>

#### 定义
> 定义一个操作中的算法的骨架(**稳定**)，而将一些步骤**延迟(变化)到子类中**。Template Method使得子类可以不改变(**复用**)一个算法的结构即可重定义(override 重写)该算法的某些特定步骤。

延迟到子类一般而言就是定义一个虚函数, 让子类去实现它们.  
在使用设计模式的时候, 我们需要能够区分哪些部分是稳定的哪些部分是变化的, 如上面就认为程序的主流程结构是相对稳定的, 更具有复用价值.

#### 结构
<div align=center><img src="https://i.imgur.com/fBirMns.png"/></div>

上面的结构中, 红色部分是稳定的, 而蓝色部分是变化的.

#### 要点总结
* Template Method模式它用最简洁的机制（虚函数的多态性）为很多应用程序框架提供了灵活的扩展点(扩展一般指的就是继承+多态)
* Template Method 有典型的“不要调用我，让我来调用你”的反向控制结构。(C++利用虚函数的晚绑定机制, 其他语言中的晚绑定不一定为虚函数)
* 被Template Method调用的虚方法可以具有实现，也可以没有任何实现（抽象方法、纯虚方法），但一般推荐将它们设置为protected方法(一般不供外界调用)。

### 策略模式
#### 动机
* 在软件构建过程中，某些对象使用的算法(广义的)可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常复杂；而且有时候支持不使用的算法也是一个性能负担。
* 如何在运行时根据需要透明地更改对象的算法？将算法与对象本身解耦，从而避免上述问题？

需要注意的是, 我们在设计软件的时候需要做动态的考虑, 加上一个时间轴, 将来极可能会发生哪些变化.如[这里](code/strategy_before_refactoring.cpp)一个税务系统, 将来可能需要增加新的国家,这时候需要改枚举类型, 同时加入另一个 else if 分支.  
我们可以考虑新建一个基类, 其中包含计算税率的纯虚函数.[这时候](code/strategy_after_refactoring.cpp)一个一个的算法就变成了一个一个子类, 放在时间轴上考虑, 增加新的做法的时候执只要新增一个子类继承基类, SalesOrder 就不需要变化.这就可以实现二进制单位意义的复用, 而不是源代码的复用,满足了开闭原则.

#### 定义
> 定义一系列算法，把它们一个个封装起来(使用类封装)，并且使它们可互相替换（变化, 基类的多态调用实现）。该模式使得算法可独立于使用它的客户程序(稳定)而变化（扩展，子类化）。

#### 结构
<div align=center><img src="https://i.imgur.com/2btPNP0.png"/></div>

#### 要点总结
* Strategy及其子类为组件提供了一系列可重用的算法，从而可以使得类型在 ==运行时==(多态调用)方便地根据需要在各个算法之间进行切换。
* Strategy模式 ==提供了用条件判断语句以外的另一种选择，消除条件判断语句，就是在解耦合==。(if-else 是结构化时候的分而治之的思维, 在 OO 中其实不太好, 而且未来可能有多种情况, if-eles 可能有绝对不变的情况, 如一周七天, 这中情况下可以用)
* 如果 Strategy 对象没有实例变量，那么各个上下文可以共享同一个 Strategy 对象(单例模式)，从而节省对象开销。

### 观察者模式
#### 动机
* 在软件构建过程中，我们需要为某些对象建立一种“通知依赖关系” : 一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知。如果这样的依赖关系过于紧密，将使软件不能很好地抵御变化。
* 使用面向对象技术，可以将这种依赖关系弱化，并形成一种稳定的依赖关系。从而实现软件体系结构的松耦合。

我们设计一个[文件分割器](code/SplitterBarWithoutObserver.cpp), 其中有进度条提示, 实际上分割器是有好多种实现的, 上面的设计抽象依赖于细节,违反了依赖倒置原则. 实际上 progressBar 扮演的就是一个通知的角色, 我们可以使用一个名为 [IProgress 的接口](code/SplitterBarReferactoringWithObserver.cpp)来描述通知机制, 并在 [MainForm 中](code/MainFormRefactoringWithObserver.cpp)使用主继承 + 多个接口 这种方式继承 IProgress 接口.实际上, 我们使用了list 保存观察者列表后, 一个对象状态发生改变可以支持多个观察者.  

#### 定义
> 定义对象间的一种一对多（变化）的依赖关系，以便当一个对象(Subject)的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。

#### 结构
<div align=center><img src="https://i.imgur.com/m7cIXMA.png"/></div>

上图的 Observer 相当于文件分割器中的 IProgress, `Update()` 相当于 `doProgress()`, `Notify()` 相当于 `onProgress()`.

#### 要点总结
* 使用面向对象的抽象，Observer模式使得我们可以**独立地改变目标与观察者**，从而使二者之间的依赖关系达致松耦合。
* 目标发送通知时，**无需指定观察者**，通知（可以携带通知信息作为参数）会自动传播
* 观察者自己决定是否需要订阅通知，目标对象对此一无所知。
* Observer模式是基于事件的UI框架中非常常用的设计模式，也是 MVC 模式的一个重要组成部分。(在 C# 中被称为 event 模式)

## 单一职责模式
在软件组件的设计中，如果**责任划分的不清晰**，使用继承得到的结果往往是随着需求的变化，子类急剧膨胀，同时充斥着重复代码，这时候的关键是==划清责任==。
典型模式:
* Decorator
* Bridge

### 装饰模式
我们考虑一个流相关的操作, 流可能是文件流/网络流/内存流, 操作可能是加密/ 缓存/两者都有, 这时候一个[平凡的实现](code/streamTrivialImpl.cpp)需要 $1 + n + n \times m !/2$ 个类, 同时膨胀出非常多的冗余代码. <div align=center><img src="https://i.imgur.com/UFdSonL.png"/></div>

我们[一个重构的思路](code/streamWithDecorator.cpp)是用组合替代继承, 再通过组合的对象多态调用, 将编译时的装配换成运行时装配. [再进一步](code/streamWithAbstractDecorator.cpp), 我们可以将两个操作的共同点提取出一个中间类 DecoratorOfStream(通过组合实现多态调用, 同时继承 Stream 以保证接口的一致性).这时候就只需要实现 $1 + n + 1 + m$ 个类:<div align=center><img src="https://i.imgur.com/cRznkzI.png"/></div>

#### 动机
* 在某些情况下我们可能会“过度地使用继承来扩展对象的功能”，由于**继承为类型引入的静态特质**(如最早实现中的 `FileStream::Read(number)`这类操作,重构后使用多态指针调用虚函数就是动态特质, 由组合实现)，使得这种扩展方式缺乏灵活性；并且随着子类的增多（扩展功能的增多），各种子类的组合（扩展功能的组合）会导致更多子类的膨胀。
* 如何使“对象功能的扩展”能够根据需要来动态地实现？同时避免“扩展功能的增多”带来的子类膨胀问题？从而使得任何“功能扩展变化”所导致的影响将为最低？

#### 定义
> 动态（**通过组合实现**）地给一个对象增加一些额外的职责。就增加功能而言，Decorator 模式比生成子类（继承）更为灵活（消除重复代码 & 减少子类个数）。

#### 结构
<div align=center><img src="https://i.imgur.com/QclFfwe.png"/></div>

#### 要点总结
* 通过采用组合而非继承的手法， Decorator 模式实现了在 ==运行时动态扩展对象功能== 的能力，而且可以根据需要扩展多个功能。避免了使用继承带来的 “灵活性差” 和 “多子类衍生问题”。
* Decorator 类在接口上表现为 is-a Component 的继承关系，即 Decorator 类继承了 Component 类所具有的接口。但在实现上又表现为 has-a Component 的组合关系，即 Decorator 类又使用了另外一个 Component 类。
* Decorator模式应用的要点在于解决 “==主体类在多个方向上的扩展功能==”

### 桥模式
#### 动机
* 由于某些类型的固有的实现逻辑，使得它们具有两个变化的维度，乃至多个纬度的变化。
* 如何应对这种“多维度的变化”？如何利用面向对象技术来使得类型可以轻松地沿着两个乃至多个方向变化，而不引入额外的复杂度？

例如我们实现一个 [Messager 类](code/MessagerTrivalImpl.cpp), 在 PC 和 Mobile 两个平台都要有 Lite 和 Perfect 两种模式, 这时候需要实现 $1 + n + m\times n$ 个类(m 中各个功能没有交叉), 并且其中有很多重复的冗余代码.  
这时候我们可以把父类变成一个字段(组合替代继承),再声明为同一个基类, 并将 `PCMessagerBase::Connect()` 这种静态调用转为 `m_messager->Connect()`. 然后再把公共的部分提取出来作为基类, 得到了[使用桥模式重构的版本](code/MessagerRefactoringWithBridge.cpp).

#### 定义
> 将抽象部分(业务功能)与实现部分(平台实现)分离，使它们都可以独立地变化。

因为这两个变化的方向不应该在一个类中同时实现.

#### 结构
<div align=center><img src="https://i.imgur.com/Z2zJIM6.png"/></div>

#### 要点总结
* Bridge模式使用“对象间的**组合关系**”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自纬度的变化，即“子类化”它们。
* Bridge模式有时候类似于多继承方案，但是多继承方案往往违背单一职责原则（即一个类只有一个变化的原因），复用性比较差。Bridge模式是比多继承方案更好的解决方法。
* Bridge模式的应用一般在“两个非常强的变化维度”，有时一个类也有多于两个的变化维度，这时可以使用Bridge的扩展模式。

## 对象创建模式
通过“对象创建” 模式**绕开 _new_**，来避免对象创建（new）过程中所导致的紧耦合（依赖具体类），从而支持对象创建的稳定。它是接口抽象之后的第一步工作。  
它有下面四种典型, 解决的是同一个问题, 只是在实际场景中有少许不同:
* Factory Method
* Abstract Factory
* Prototype
* Builder

### 工厂方法模式
#### 动机
* 在软件系统中，经常面临着创建对象的工作；由于需求的变化，需要**创建的对象的具体类型经常变化**。
* 如何应对这种变化？如何绕过常规的对象创建方法(new)，提供一种“封装机制”来避免客户程序和这种“具体对象创建工作”的紧耦合？

例如, 如果我们想要一个文件分割器, 以应对不同的格式的文件(图片/二进制文件/文本/视频 etc.), 一个平凡的[实现](code/FileSplitterForMultiFormat.cpp)是使用面向对象的方法定义好接口, 然后不同的类继承这个接口, 在[调用端](code/FileSplitterForMultiFormatMainForm.cpp)是依赖于具体类的, 这违反了依赖倒置原则.  
创建对象除了 new 外还有一种方式, 就是**使用一个函数返回**, 可以创建一个[工厂的基类](code/ISplitterFactory.cpp), 其中包含一个纯虚函数 `CreateSplitter()`返回一个抽象 Splitter 对象, 而将**创建函数的具体的实现延迟到其[子类](code/ISplitterConcretFactory.cpp)**(每个类的具体工厂), 这时候在 [MainForm 调用端](code/ISplitterFactoryMainForm.cpp)只需要传入一个工厂基类的子类的实例, 通过实例实现了**多态 _new_**,这时候 mainform 再也没有具体类的依赖: 这时候并不是把依赖具体类给消灭了, 而是将它限制在可控的范围.  
我们可以进一步将 Init 拆分到 HouseDirector 中, 在其中包含一个 House 指针. 

#### 定义
> 定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使得一个类的实例化延迟（目的：解耦，手段：虚函数）到子类。

#### 结构
<div align=center><img src="https://i.imgur.com/i2nmFLp.png"/></div>

这时候调用端只是依赖于上面的稳定部分, 明显实现了解耦. 

#### 要点总结
* Factory Method模式用于隔离类对象的使用者和具体类型之间的耦合关系。面对一个经常变化的具体类型，紧耦合关系(new)会导致软件的脆弱。
* Factory Method模式通过面向对象的手法，将所要创建的具体对象工作延迟到子类，从而实现一种扩展（而非更改）的策略，较好地解决了这种紧耦合关系。
* Factory Method模式解决“单个对象”的需求变化。缺点在于要求创建方法/参数相同。

### 抽象工厂模式
#### 动机
* 在软件系统中，经常面临着<font color=red>“一系列相互依赖的对象”</font>的创建工作；同时，由于需求的变化，往往存在更多系列对象的创建工作
* 如何应对这种变化？如何绕过常规的对象创建方法(new)，提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？

例如, 我们要对数据库的操作[直接使用 new](code/EmployeeDAO.cpp) 就会有非常紧密的耦合, 导致更换数据库类型后需要修改大量的代码. 改进的[一个方案](code/EmployeeDAOWithFactory.cpp)就是使用多个虚基类, IDBConnection/IDBConnectionFactory/IDBCommand/IDBCommandFactory/IDataReader/IDataReaderFactory, 在实际工程中, 工厂和实现可以放在不同的文件(编译单元)中, 这个方案初步实现了松耦合.但有一个严重的问题就是, Connection/Command/DataReader 三者其实是有关系的, 我们不能使用 MySQL 的 Connection 但是传入一个 Oracle 的 Command.  
[解决的办法](code/EmployeeDAOWithAbstractFactory.cpp)就是将三个创建的成员函数放在一个工厂中, 实现了**高内聚/松耦合**的设计, 这时候在一个工厂中就确保了关联性.抽象工厂可能不够直观, 如果叫家族工厂则更好理解. 

#### 定义
> 提供一个接口，让该接口负责创建一系列“相关或者相互依赖的对象”，无需指定它们具体的类

#### 结构
<div align=center><img src="https://i.imgur.com/3MgVEpo.png"/></div>

#### 要点总结
* 如果没有应对“多系列对象构建”的需求变化，则没有必要使用 Abstract Factory 模式，这时候使用简单的工厂完全可以
* “系列对象”指的是在某一特定系列下的对象之间有相互依赖、或作用的关系。不同系列的对象之间不能相互依赖。
* Abstract Factory 模式主要在于应对“新系列”(如新的数据库类型)的需求变动。其缺点在于难以应对“新对象”(如所有数据库加入新的操作, 则需要改变抽象的基类, 这在本模式中应该是稳定的)的需求变动。

### 原型模式
#### 动机
* 在软件系统中, 经常面临着**某些结构复杂的对象**(和工厂方法的主要区别,默认的初始状态不是我们想要的,需要调用深克隆把原型的状态也复制过来)的创建工作, 由于需求的变化, 这些对象经常面临着剧烈的变化, 他们却拥有比较稳定一致的接口
* 如何应对这种变化? 如何向客户程序隔离出这些易变对象, 使得依赖这些易变对象的客户程序不随着需求的改变而改变

例如, 我们前面使用工厂模式写出文件分割器, 可以将[工厂类和抽象类合并](code/Prototype.cpp), 然后[创建对象的 clone 方法](code/PrototypeConcreteImpl.cpp)中调用拷贝构造函数并且传入解引用的 this 指针, 这时候就不需要具体的工厂, 在客户端原型对象可供我们用以创建新的对象.

#### 定义
> 使用**原型实例**指定创建对象的种类, 然后通过拷贝(**深克隆**,否则后面会改变原型实例的状态)这些原型来创建新的对象.(主要的问题在于对象的结构比较复杂, 需要勇实例调用拷贝构造函数才能完成完整的创建过程)

#### 结构
这个模式的关键在于是 return 自己的深克隆副本:<div align=center><img src="https://i.imgur.com/tOmGeKW.png"/></div>

#### 要点总结
* 原型模式同样用于各留对象的使用者和具体类型(变化)之间的耦合关系, 要求这些易变的类拥有**稳定的接口**
* 原型模式在穿件中采用**对象克隆**的方法, 使得我们可以非常灵活地动态创建拥有某些稳定接口(以及想要的状态)的新对象, 具体工作就是注册一个新类的对象, 然后在需要的地方克隆
* Clone 方法可以利用某些框架中的序列化(在拷贝构造不那么方便的语言, 如 Java/C# 中)来实现深拷贝

### 构建器模式
#### 动机
* 在软件系统中，有时候面临着“一个复杂对象”的创建工作，创建过程通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的**各个部分经常面临着剧烈的变化**， 但是将它们**组合在一起的算法却相对稳定**。
* 如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？

例如我们在一个游戏中建房子, 不同的房子(茅草屋/砖瓦房)构建的具体实现不同, 但是有相似的流程(有点像 template method).C++ 中调用构造函数是静态绑定, 所以流程不能写在构造器中(子类的构造函数会先调用父类的构造函数, 使用虚机制的话, 可能子类的那些部分还没有实现, 故无法调用), 我们将过程放在 `Init()` 中.  
[进一步](code/HouseBuilder.cpp)我们可以单独将 Init() 拆分到 HouseDirector 中, 这个类组合一个 HouseBuilder 指针, 再通过它的指针调用具体的构建过程.

#### 定义
> 将一个复杂对象的构建(HouseBuilder)与其表示(House)相分离，使得同样的构建过程(稳定)可以创建不同的表示(变化)。

#### 结构
<div align=center><img src="https://i.imgur.com/y3Hsf3h.png"/></div>

#### 要点总结
* Builder 模式主要用于“分步骤构建一个复杂的对象”。在这其中 **“分步骤”是一个稳定的算法，而复杂对象的各个部分则经常变化**。
* 在Builder模式中，要注意不同语言中构造器内调用虚函数的差别(C++ vs. C#) 。

## 对象性能模式
面向对象很好地解决了 "抽象" 的问题，但是必不可免地要付出 一定的代价。对于通常情况来讲,面向对象的成本大都可以忽略不计。但是某些情况，面向对象所带来的成本必须谨慎处理。
* 单件模式
* 享元模式
### 单件模式
#### 动机
* 在软件系统中，经常有这样一些特殊的类，必须保证它们在系统中只存在一个实例，才能确保它们的逻辑正确性、以及良好的效率。
* 如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例？
* 这应该是类设计者的责任，而不是使用者的责任。

[典型的实现](code/Singleton.cpp)中, 我们要将类的构造函数设置为 private, 然后有一个静态变量(Pointer to Singleton,需要类外初始化) 和一个静态的成员函数(`getInstance()`).  
为了解决线程安全问题, 我们可以加一个局部的锁,执行完毕后会释放, 这个版本加锁的代价是很高的(对于都是读的过程有浪费). 这时候有个非常有名的视线: 双检查锁, 先问变量是不是空, 只有变量是空的时候才加锁. 
```C++
Singleton* Singleton::getInstance(){
  if(m_instance == null){
    Lock lock;
    if(m_instance == nullptr){
      m_instance = new Singleton();
    }
    return m_instance;
  }
}
``` 
上面的实现在内存读写 reorder 出现后会不安全. 
> reorder: 代码的指令序列在汇编层级可能不同, 上面的 new 过程其实是三步: 先分配内存, 然后调用构造函数, 然后将地址赋值给 m_instance. 这三步可能会改变(编译器优化), 如先分配内存, 然后将地址给 m_instance, 然后再调用构造器: 另一个线程在第二步之后进入, 发现 m_instance 不是 nullptr, 直接返回 m_instance, 这时候它指向的**地址上还没有完成初始化过程**, 行为是未定义的.

在java/C# 中加一个关键字 `volatile`,编译器就知道那里不能 reordering. C++ 直到 C++11 之后才有比较好的跨平台实现:<div align=center><img src="https://i.imgur.com/xSMPTtC.png"/></div>

#### 定义
> 保证一个类仅有一个实例/ 并提供一个该实例的全局访问点。

#### 结构
<div align=center><img src="https://i.imgur.com/r3783sJ.png"/></div>

#### 要点总结
* Singleton 模式中的实例构造器可以设置为 protected 以允许子类派生。
* Singleton模式一般不要支持拷贝构造函数和 Clone 接口 ，因为这有可能导致多个对象实例，与 Singleton 模式的初衷违背。
* 如何实现多线程环境下安全的 Singleton? 注意对双检查锁的正确实现。

### 享元模式
#### 动机
* 在软件系统采用纯粹对象方案的问题在千大量细粒度的对象会很快充斥在系统中，从而带来很高的运行时代价——主要指内存需求方面的代价。
* 如何在避免大量细粒度对象问题的同时，让外部客户程序仍然能够透明地使用面向对象的方式来进行操作？

#### 定义
> 运用**共享**技术有效地支持**大量细粒度的对象**。

#### 结构
<div align=center><img src="https://i.imgur.com/bWyHP3C.png"/></div>

例如我们需要一个 Font 处理的系统, 在一般的场景中, 我们只在一个文档中使用少数几种字体, 如果每个字符都创建一个字体就会带来繁重的开销. 我们在[实现](code/FontFlyweight.cpp)中创建了一个工厂, 使用一个 map 类型的 fontPool, 需要的时候往 map 里查询, 有的话直接返回, 查询不到的时候才创建新的 Font 对象insert 到 map 中以后返回.

#### 要点总结
* 面向对很好地解决了抽象性的问题但是作为—个运行在机器中的程序实体，我们需要考虑对象的代价问题。Flyweight 主要解决面向对象的代价问题，一般不触及面向对象的抽象性问题。
* Flyweight 采用对象共享的方法降低系统中的对象个数, 从而降低细粒度对象给系统带来的内存压力, 在具体实现方面, 要注意对象状态的处理(对象最好是 read-only)
* 数量大没有严格的界定, 要根据应用场景进行评估, 而不能凭空臆断

## 接口隔离模式
在组件构建过程中，某些接口之间直接的依赖常常会带来很多可题、甚至根本无法实现。采用添加一层**间接**（稳定）接口，来隔离本来互相紧密关联的接口是—种常见的解决方案。
* façade
* Proxy
* Adapter
* Mediator
### façade 门面模式
<div align=center><img src="https://i.imgur.com/QYkYkYW.png"/></div>

#### 动机
* 上述A方案的问题在于组件的客户和组件中各种复杂的子系统有了过多的耦合，随着外部客户程序和各子系统的演化，这种过多的耦合面临很多变化的挑战。
* 如何简化外部客户程序和系统间的交互接口？如何将外部客户程序的演化和内部子系统的变化之间的依赖相互解耦？

#### 定义
> 为子系统中的一组接口提供一个一致(稳定)的界面, façade 模式定义了一个高层接口, 这个接口使得这一子系统更加容易使用.

#### 结构
这个模式没有统一的代码结构,它体现了一种设计原则的表达, 用稳定的接口隔离变化体. <div align=center><img src="https://i.imgur.com/v4UTylD.png"/></div>

#### 要点总结
* 从客户程序的角度看, 该模式简化了整个组件系统的接口, 对于组件内部与外部客户程序来说, 达到了一种解耦的效果: **内部子系统的任何变化不会影响到 Facade 接口的变化**
* Facade 设计模式更注重从架构的层次去看整个系统，而不是单个类的层次。Facade很多时候更是一种架构设计模式。
* Facade 模式并非一个集装箱, 组件内部应该是**相互耦合关系比较大的一系列组件**, 而非一个简单的功能集合

### Proxy 代理模式
#### 动机
* 在面向对象系统中，有些对象由千某种原因（比如对象创建的开销很大，或者某些操作需要安全控制，或者需要进程外的访问等），直接访问会给使用者、或者系统结构带来很多麻烦。
* 如何在不失去透明操作(和直接访问一致)对象的同时来管理／控制这些对象特有的复杂性？**增加一层间接层是软件开发中常见的解决方式**。

#### 定义
> 为其他对象提供一种代理以控制（**隔离**，使用接口）对这个对象的访问。

#### 结构
<div align=center><img src="https://i.imgur.com/XdvnPpk.png"/></div>

一个简单的[实现](code/clientWithProxy.cpp) 相对于[没有使用 Proxy模式的代码](code/clientWithoutProxy.cpp) 就是在客户端使用的是 Proxy类(和 real类派生紫同一接口)调用具体的操作, 但是实际工作中可能有更复杂的行为.

#### 要点总结
<div align=center><img src="https://i.imgur.com/83QL7ni.png"/></div>

### 适配器
#### 动机
* 在软件系统中，由于应用环境的变化，常常需要将“一些现存的对象”放在新的环境中应用，但是新环境要求的接口是这些现存对象的接口是不匹配的。
* 如何应对这种“迁移的变化”？如何既能利用现有对象的良好实现，同时又能满足新的应用环境所要求的接口？

#### 定义
> 将一个类的接口转换为客户希望的另一个接口, 使得原本由于接口不兼容而不能一起工作的那些类可以一起工作

#### 结构
<div align=center><img src="https://i.imgur.com/1uwEy3C.png"/></div>

在这里我们是希望在将来的应用场景和现有的类都保持稳定.在很多[实现](code/Adapter.cpp)中, adapter 这个类是在继承 Target 类(遵循它的规范), 同时组合一个具体实现类. 在 STL 中, stack 就是一种类适配器模板, 内含一个 deque 容器, 并没有和这个结构完全一致, 但是是一种变体. 
#### 要点总结
* Adapter模式主要应用于"希望复用一些现存的类，但是接口又与复用境要求不一致的清况" ，在遗留代码复用、类库迁移等方面非常有用。
* GoF23 定义了两种 Adapter模式的实现结构：对象适配器和类适配器。
  * 类适配器采用 "多继承" 的实现方式，一般不推荐使用(一般使用 proteced(多用于实现继承)继承的方式)
  * 对象适配器采用“对象组合”的方式，更符合松耦合精神(指针更灵活)
* 适配器模式可以非常灵活