# C++ 设计模式
## Lec 1: Intro
课程目标:
* 理解松耦合设计思想
* 掌握面向对象的设计原则
* 掌握重构激发改善设计
* 掌握 GoF 核心设计模式

> 每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动。

可复用是我们的设计目标, 面向对象是我们具体使用的方法. OO 涉及编程中常见的抽象思维,帮助我们很好地管理代码的复杂度:<div align=center><img src="https://i.imgur.com/ECexQDt.png"/></div>

OO 向下主要有三种机制:
* 封装: 如何隐藏内部实现
* 继承: 复用现有的代码
* 多态: 改写对象的行为

而向上需要掌握==什么是好的面向对象设计==.

我们解决复杂性有两种常见的做法:
* 分解: 将大问题分解成多个小问题, 复杂问题分解为多个简单问题(结构化编程时候常用)
* ==抽象==: 由于不能掌握全部的的复杂对象，我们选择忽视它的非本质细节，而去处理泛化和理想化了的对象模型。

## Lec 2: 面向对象的设计原则
变化是复用的天敌, ==面向对象设计的最大优势在于抵御变化==.
* 理解隔离变化
  * 从宏观层面来看，面向对象的构建方式更能适应软件的变化，能将变化所带来的影响减为最小
* 各司其职
  * 从微观层面来看，==面向对象的方式更强调各个类的“责任”==
  * 由于需求变化导致的新增类型不应该影响原来类型的实现——是所谓各负其责
* 对象是什么
  * 从语言实现层面来看，对象封装了代码和数据
  * 从规格层面讲，对象是一系列可被使用的公共接口
  * 从概念层面讲，对象是某种==拥有责任的抽象==

### 面向对象的设计原则
* ==依赖倒置原则==(DIP)
  * 高层模块(==稳定==)不应该依赖于低层模块(==变化==)，二者都应该依赖于抽象(==稳定==) 。
  * 抽象(稳定)不应该依赖于实现细节(变化) ，实现细节应该依赖于抽象(稳定)。<div align=center><img src="https://i.imgur.com/26kay53.png"/></div>
* 开放封闭原则（OCP）
  * 对扩展开放，对更改封闭
  * 类模块应该是可扩展的，但是不可修改
* 单一职责原则（SRP）
  * 一个类应该仅有一个引起它变化的原因。
  * 变化的方向==隐含着类的责任==(多个责任把类往不同的方向拉扯)
* Liskov 替换原则（LSP）
  * 子类必须能够替换它们的基类(IS-A)
  * 继承表达类型抽象
* 接口隔离原则(ISP)
  * 接口应该小而完备
  * 不应该强迫客户程序依赖它们不用的方法
* 优先使用对象组合，而不是类继承
  * 继承关系更像是类属关系而不是父子关系
  * 继承在某种程度上破坏了封装性，==子类父类耦合度高==。
  * 而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。
* 封装变化点
  * 使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。
* 针对接口编程，而不是针对实现编程(和 DIP 相辅相成, 从不同角度看同一个问题)
  * 不将变量类型声明为某个特定的具体类，而是声明为某个接口
  * 客户程序无需获知对象的具体类型，只需要知道对象所具有的接口
  * 减少系统中各部分的依赖关系，从而实现“高内聚、松耦合”的类型设计方案。

## 组件协作模式
GoF 中 23 种模式的分类:
* 从目的来看：
  * 创建型（Creational）模式：将对象的部分创建工作延迟到子类或者其他对象，从而应对需求变化为对象创建时具体类型实现引来的冲击。
  * 结构型（Structural）模式：通过类继承或者对象组合获得更灵活的结构，从而应对需求变化为对象的结构带来的冲击。
  * 行为型（Behavioral）模式：通过类继承或者对象组合来划分类与对象间的职责，从而应对需求变化为多个交互的对象带来的冲击。
* 从范围看:
  * 类模式处理类与子类的静态关系: 偏向于继承方案
  * 对象模式处理对象间的动态关系: 偏向于组合模式
* 从封装变化的角度看<div align=center><img src="https://i.imgur.com/CKfgJmV.png"/></div>

学习设计模式的重要方法是由重构获得模式:
* 面向对象设计模式是“好的面向对象设计”，所谓“好的面向对象设计”指是那些可以满足“==应对变化，提高复用==”的设计
* 现代软件设计的特征是“需求的频繁变化”。设计模式的要点是 “==寻找变化点，然后在变化点处应用设计模式，从而来更好地应对需求的变化==”.“什么时候、什么地点应用设计模式”比“理解设计模式结构本身”更为重要。
* 设计模式的应用不宜先入为主，没有一步到位的设计模式。敏捷软件开发实践提倡的 “Refactoring to Patterns” 是目前普遍公认的最好的使用设计模式的方法。

重构有很多关键的技法:他们其实是从不同的角度看待同一个问题
* 静态 -> 动态
* 早绑定 -> 晚绑定
* 继承 -> 组合
* 编译时依赖 -> 运行时依赖
* 紧耦合 -> 松耦合

现代软件专业分工之后的第一个结果是 “框架与应用程序的划分”，“组件协作”模式通过==晚期绑定==，来实现 **框架与应用程序之间的松耦合**，是二者之间协作时常用的模式。
* Template Method
* Observer / Event
* Strategy

### Template Method
#### 动机
* 在软件构建过程中，对于某一项任务，它常常有==稳定的整体操作结构==，但各个子步骤却有很多==改变的需求==，或者由于固有的原因（比如框架与应用之间的关系）而无法和任务的整体结构同时实现
* 如何在确定稳定操作结构的前提下，来灵活应对各个子步骤的变化或者晚期实现需求？

<div align=center><img src="https://i.imgur.com/h5f3t13.png"/></div>
<div align=center><img src="https://i.imgur.com/IMxf5nR.png"/></div>

可以看到, 第一种是早绑定的方法, 晚实现的 Application 调用早实现的 Library, 是一种早绑定的方法, 而下面的刚好相反.<div align=center><img src="https://i.imgur.com/VdabRuf.png"/></div>

#### 定义
> 定义一个操作中的算法的骨架(**稳定**)，而将一些步骤**延迟(变化)到子类中**。Template Method使得子类可以不改变(**复用**)一个算法的结构即可重定义(override 重写)该算法的某些特定步骤。

延迟到子类一般而言就是定义一个虚函数, 让子类去实现它们.  
在使用设计模式的时候, 我们需要能够区分哪些部分是稳定的哪些部分是变化的, 如上面就认为程序的主流程结构是相对稳定的, 更具有复用价值.

#### 结构
<div align=center><img src="https://i.imgur.com/fBirMns.png"/></div>

上面的结构中, 红色部分是稳定的, 而蓝色部分是变化的.

#### 要点总结
* Template Method模式它用最简洁的机制（虚函数的多态性）为很多应用程序框架提供了灵活的扩展点(扩展一般指的就是继承+多态)
* Template Method 有典型的“不要调用我，让我来调用你”的反向控制结构。(C++利用虚函数的晚绑定机制, 其他语言中的晚绑定不一定为虚函数)
* 被Template Method调用的虚方法可以具有实现，也可以没有任何实现（抽象方法、纯虚方法），但一般推荐将它们设置为protected方法(一般不供外界调用)。

### 策略模式
#### 动机
* 在软件构建过程中，某些对象使用的算法(广义的)可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常复杂；而且有时候支持不使用的算法也是一个性能负担。
* 如何在运行时根据需要透明地更改对象的算法？将算法与对象本身解耦，从而避免上述问题？

需要注意的是, 我们在设计软件的时候需要做动态的考虑, 加上一个时间轴, 将来极可能会发生哪些变化.如[这里](code/strategy_before_refactoring.cpp)一个税务系统, 将来可能需要增加新的国家,这时候需要改枚举类型, 同时加入另一个 else if 分支.  
我们可以考虑新建一个基类, 其中包含计算税率的纯虚函数.[这时候](code/strategy_after_refactoring.cpp)一个一个的算法就变成了一个一个子类, 放在时间轴上考虑, 增加新的做法的时候执只要新增一个子类继承基类, SalesOrder 就不需要变化.这就可以实现二进制单位意义的复用, 而不是源代码的复用,满足了开闭原则.

#### 模式定义
> 定义一系列算法，把它们一个个封装起来(使用类封装)，并且使它们可互相替换（变化, 基类的多态调用实现）。该模式使得算法可独立于使用它的客户程序(稳定)而变化（扩展，子类化）。

#### 结构
<div align=center><img src="https://i.imgur.com/2btPNP0.png"/></div>

#### 要点总结
* Strategy及其子类为组件提供了一系列可重用的算法，从而可以使得类型在 ==运行时==(多态调用)方便地根据需要在各个算法之间进行切换。
* Strategy模式 ==提供了用条件判断语句以外的另一种选择，消除条件判断语句，就是在解耦合==。(if-else 是结构化时候的分而治之的思维, 在 OO 中其实不太好, 而且未来可能有多种情况, if-eles 可能有绝对不变的情况, 如一周七天, 这中情况下可以用)
* 如果 Strategy 对象没有实例变量，那么各个上下文可以共享同一个 Strategy 对象(单例模式)，从而节省对象开销。

### 观察者模式
#### 动机
* 在软件构建过程中，我们需要为某些对象建立一种“通知依赖关系” : 一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知。如果这样的依赖关系过于紧密，将使软件不能很好地抵御变化。
* 使用面向对象技术，可以将这种依赖关系弱化，并形成一种稳定的依赖关系。从而实现软件体系结构的松耦合。

我们设计一个[文件分割器](code/FileSplitterWithoutObserver.cpp), 其中有进度条提示, 实际上分割器是有好多种实现的, 上面的设计抽象依赖于细节,违反了依赖倒置原则. 实际上 progressBar 扮演的就是一个通知的角色, 我们可以使用一个名为 [IProgress 的接口](code/FileSplitterReferactoringWithObserver.cpp)来描述通知机制, 并在 [MainForm 中](code/MainFormRefactoringWithObserver.cpp)使用主继承 + 多个接口 这种方式继承 IProgress 接口.实际上, 我们使用了list 保存观察者列表后, 一个对象状态发生改变可以支持多个观察者.  

#### 定义
> 定义对象间的一种一对多（变化）的依赖关系，以便当一个对象(Subject)的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。

#### 结构
<div align=center><img src="https://i.imgur.com/m7cIXMA.png"/></div>

上图的 Observer 相当于文件分割器中的 IProgress, `Update()` 相当于 `doProgress()`, `Notify()` 相当于 `onProgress()`.

#### 要点总结
* 使用面向对象的抽象，Observer模式使得我们可以**独立地改变目标与观察者**，从而使二者之间的依赖关系达致松耦合。
* 目标发送通知时，**无需指定观察者**，通知（可以携带通知信息作为参数）会自动传播
* 观察者自己决定是否需要订阅通知，目标对象对此一无所知。
* Observer模式是基于事件的UI框架中非常常用的设计模式，也是 MVC 模式的一个重要组成部分。(在 C# 中被称为 event 模式)

## 单一职责模式
在软件组件的设计中，如果**责任划分的不清晰**，使用继承得到的结果往往是随着需求的变化，子类急剧膨胀，同时充斥着重复代码，这时候的关键是==划清责任==。
典型模式:
* Decorator
* Bridge

### 装饰模式
我们考虑一个流相关的操作, 流可能是文件流/网络流/内存流, 操作可能是加密/ 缓存/两者都有, 这时候一个[平凡的实现](code/streamTrivialImpl.cpp)需要 $1 + n + n \times m !/2$ 个类, 同时膨胀出非常多的冗余代码. <div align=center><img src="https://i.imgur.com/UFdSonL.png"/></div>

我们[一个重构的思路](code/streamWithDecorator.cpp)是用组合替代继承, 再通过组合的对象多态调用, 将编译时的装配换成运行时装配. [再进一步](code/streamWithAbstractDecorator.cpp), 我们可以将两个操作的共同点提取出一个中间类 DecoratorStream(通过组合实现多态调用, 同时继承 Stream 以保证接口的一致性).这时候就只需要实现 $1 + n + 1 + m$ 个类:<div align=center><img src="https://i.imgur.com/cRznkzI.png"/></div>

#### 动机
* 在某些情况下我们可能会“过度地使用继承来扩展对象的功能”，由于**继承为类型引入的静态特质**(如最早实现中的 `FileStream::Read(number)`这类操作,重构后使用多态指针调用虚函数就是动态特质, 由组合实现)，使得这种扩展方式缺乏灵活性；并且随着子类的增多（扩展功能的增多），各种子类的组合（扩展功能的组合）会导致更多子类的膨胀。
* 如何使“对象功能的扩展”能够根据需要来动态地实现？同时避免“扩展功能的增多”带来的子类膨胀问题？从而使得任何“功能扩展变化”所导致的影响将为最低？

#### 定义
> 动态（**通过组合实现**）地给一个对象增加一些额外的职责。就增加功能而言，Decorator 模式比生成子类（继承）更为灵活（消除重复代码 & 减少子类个数）。

#### 结构
<div align=center><img src="https://i.imgur.com/QclFfwe.png"/></div>

#### 总结
* 通过采用组合而非继承的手法， Decorator 模式实现了在 ==运行时动态扩展对象功能== 的能力，而且可以根据需要扩展多个功能。避免了使用继承带来的 “灵活性差” 和 “多子类衍生问题”。
* Decorator 类在接口上表现为 is-a Component 的继承关系，即 Decorator 类继承了 Component 类所具有的接口。但在实现上又表现为 has-a Component 的组合关系，即 Decorator 类又使用了另外一个 Component 类。
* Decorator模式应用的要点在于解决 “==主体类在多个方向上的扩展功能==”