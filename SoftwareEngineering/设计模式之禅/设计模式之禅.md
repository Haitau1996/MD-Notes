# 设计模式之禅
## Part I : 6大设计原则解读
### Chap 1: 单一职责原则
单一职责原则的争议之处在于, 什么是类的职责, 如何划分职责.如我们设计一个 Role-Based Access Control 的用户信息管理类:<br>
![](https://gitee.com/Haitau1996/picture-hosting/raw/master/img/20210419100307.png)<br>
其中用户的属性和用户的行为没有分开, 应该将它抽象为一个业务对象和一个业务逻辑:<br>
![](https://gitee.com/Haitau1996/picture-hosting/raw/master/img/20210419100551.png)<br>
单一职责的定义是: **应该有且只有一个原因引起类的变更**(There should never be more than one reason for a class to change), 实际上我们更倾向于使用两个不同的类或者接口:<br>
![](https://gitee.com/Haitau1996/picture-hosting/raw/master/img/20210419100814.png)<br>
再举一个例子, 就是电话通话的过程, 实际上包含了协议管理和数据传输两个东西, 因此倾向于这样设计类:<br>
![](https://gitee.com/Haitau1996/picture-hosting/raw/master/img/20210419101153.png)<br>
单一职责最难的在于如何划分职责, 并且没有量化的标准, 单一职责不但适用于接口和类, 也适用于方法.同一的建议是:**接口一定要做到单一职责, 类的设计尽量做到只有一个原因引起变化**.

### Chap 2: 里式替换原则
对于继承, 我们需要了解它有下面几个问题:
* 继承是侵入性的, 降低了代码的灵活性
* 继承增加了耦合性, 而我们想要松耦合

为了尽量减少这些问题带来的困扰, 我们引入里氏替换原则:**所有引用基类的地方必须能够透明地使用其子类的对象**.<br>
我们设计了一个FPS 游戏, 引入了不同的步枪:<br>
![](https://gitee.com/Haitau1996/picture-hosting/raw/master/img/20210420092528.png)<br>
其中士兵类的实现如下:
```Java
public class Soldier {
    //定义士兵的枪支
    private AbstractGun gun;
    //给士兵一支枪
    public void setGun(AbstractGun _gun){
        this.gun = _gun;
    }
    public void killEnemy(){
        System.out.println("士兵开始杀敌人...");
        gun.shoot();
    }
}
```
在类中调用其他类(如上面的发枪使用的是 AbstractGun)时候使用父类或者接口, 如果不能的话,说明类的设计已经违背了 LSP 原则.<br>
如果引入一个玩具手枪类, 按照上面的类图调用类出现了问题, 正常的业务逻辑无法运行. 这时候可以有两种做法:
* :sob: 增加 instanceof 判断, 如果是玩具枪那么就不能开火
* :yum: ToyGun 脱离继承, 建立一个独立的父类, 可以与抽象墙类建立委托关系:
  ![](https://gitee.com/Haitau1996/picture-hosting/raw/master/img/20210420093554.png)

此外需要注意的是, 里氏替换原则不能反过来用, 子类出现的地方, 父类未必能胜任. 但是有一个问题就是输入参数范围的变化, 输入参数被称为前置条件, **里氏替换原则要求制定一个契约, 就是父类或者接口**, 这种设计方法叫做 Design By Contract. 我们要求<b><font color=red> 子类中方法的前置条件必须与父类中的前置条件相同或者更宽松</font></b>, 否则在没有 override 父类方法的前提下子类方法被执行了:
```Java
public class Father {
    public Collection doSomething(Map map){
        System.out.println("父类被执行...");
        return map.values();
    }
}
public class Son extends Father {
    //缩小输入参数范围
    public Collection doSomething(HashMap map){
        System.out.println("子类被执行...");
        return map.values();
    }
}
public class Client {
    public static void invoker(){
        //有父类的地方就有子类
        Father f= new Father();
        HashMap map = new HashMap();
        f.doSomething(map);
    }
    public static void main(String[] args) {
        invoker();
    }
}
```
上面的代码输出的结果是子类被执行, 而它并没有 override 父类的方法.

### Chap 3: 依赖倒置原则
依赖倒置原则有下面的含义:
* 高层模块不应该依赖低层模块, 两者都应该依赖其抽象
* 抽象不应该依赖细节, 细节应该依赖抽象

例如一个简单的例子, 如果司机类和奔驰类出现紧耦合, 那么可能就无法开其他品牌的汽车. **稳定性较高的设计, 在周围环境频繁变化的时候, 依然可以做到我自岿然不动**.现在的软件开发需要协作和并行开发, 这就需要解决模块之间的项目依赖关系. 于是我们可以如此设计司机和车的关系:<br>
![](https://gitee.com/Haitau1996/picture-hosting/raw/master/img/20210420100733.png)<br>
在 Java 中, 一个变量可以有两种类型, 声明类型和实际类型. 在 TDD 中, 我们可以引入 JMock 工具, 根据抽象虚拟一个对象进行测试:
```Java
public class DriverTest extends TestCase{
    Mockery context = new JUnit4Mockery();
    @Test
    public void testDriver() {
        //根据接口虚拟一个对象
        final ICar car = context.mock(ICar.class);
        IDriver driver = new Driver();
        //内部类
        context.checking(new Expectations(){{
        oneOf (car).run();
        }});
        driver.drive(car);
    }
}
```
依赖是可以传递的, 但是只**要做到抽象依赖**, 多层的依赖传递也是没有关系的, 有三种方法来传递依赖关系:
1. 构造函数传递依赖对象: 构造函数注入(如 Driver 构造函数中传入ICar):
   ```Java
    public interface IDriver {
        //是司机就应该会驾驶汽车
        public void drive();
    }
    public class Driver implements IDriver{
        private ICar car;
        //构造函数注入
        public Driver(ICar _car){
            this.car = _car;
        }
        //司机的主要职责就是驾驶汽车
        public void drive(){
            this.car.run();
        }
    }
    ```
2. Setter 方法传递依赖对象
3. 接口声明依赖对象

最佳实践中我们总结了一些规则:
* 每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备
* 变量的表面类型尽量是接口或者是抽象类
* 任何类都不应该从具体类派生
* 尽量不要覆写基类的方法
* 结合里氏替换原则使用