# 设计模式之禅
## Part I : 6大设计原则解读
### Chap 1: 单一职责原则
单一职责原则的争议之处在于, 什么是类的职责, 如何划分职责.如我们设计一个 Role-Based Access Control 的用户信息管理类:<br>
![](https://gitee.com/Haitau1996/picture-hosting/raw/master/img/20210419100307.png)<br>
其中用户的属性和用户的行为没有分开, 应该将它抽象为一个业务对象和一个业务逻辑:<br>
![](https://gitee.com/Haitau1996/picture-hosting/raw/master/img/20210419100551.png)<br>
单一职责的定义是: **应该有且只有一个原因引起类的变更**(There should never be more than one reason for a class to change), 实际上我们更倾向于使用两个不同的类或者接口:<br>
![](https://gitee.com/Haitau1996/picture-hosting/raw/master/img/20210419100814.png)<br>
再举一个例子, 就是电话通话的过程, 实际上包含了协议管理和数据传输两个东西, 因此倾向于这样设计类:<br>
![](https://gitee.com/Haitau1996/picture-hosting/raw/master/img/20210419101153.png)<br>
单一职责最难的在于如何划分职责, 并且没有量化的标准, 单一职责不但适用于接口和类, 也适用于方法.同一的建议是:**接口一定要做到单一职责, 类的设计尽量做到只有一个原因引起变化**.

### Chap 2: 里式替换原则
对于继承, 我们需要了解它有下面几个问题:
* 继承是侵入性的, 降低了代码的灵活性
* 继承增加了耦合性, 而我们想要松耦合

为了尽量减少这些问题带来的困扰, 我们引入里氏替换原则:**所有引用基类的地方必须能够透明地使用其子类的对象**.<br>
我们设计了一个FPS 游戏, 引入了不同的步枪:<br>
![](https://gitee.com/Haitau1996/picture-hosting/raw/master/img/20210420092528.png)<br>
其中士兵类的实现如下:
```Java
public class Soldier {
    //定义士兵的枪支
    private AbstractGun gun;
    //给士兵一支枪
    public void setGun(AbstractGun _gun){
        this.gun = _gun;
    }
    public void killEnemy(){
        System.out.println("士兵开始杀敌人...");
        gun.shoot();
    }
}
```
在类中调用其他类(如上面的发枪使用的是 AbstractGun)时候使用父类或者接口, 如果不能的话,说明类的设计已经违背了 LSP 原则.<br>
如果引入一个玩具手枪类, 按照上面的类图调用类出现了问题, 正常的业务逻辑无法运行. 这时候可以有两种做法:
* :sob: 增加 instanceof 判断, 如果是玩具枪那么就不能开火
* :yum: ToyGun 脱离继承, 建立一个独立的父类, 可以与抽象墙类建立委托关系:
  ![](https://gitee.com/Haitau1996/picture-hosting/raw/master/img/20210420093554.png)

此外需要注意的是, 里氏替换原则不能反过来用, 子类出现的地方, 父类未必能胜任. 但是有一个问题就是输入参数范围的变化, 输入参数被称为前置条件, **里氏替换原则要求制定一个契约, 就是父类或者接口**, 这种设计方法叫做 Design By Contract. 我们要求<font color=red> 子类中方法的前置条件必须与父类中的前置条件相同或者更宽松</font>, 否则在没有 override 父类方法的前提下子类方法被执行了:
```Java
public class Father {
    public Collection doSomething(Map map){
        System.out.println("父类被执行...");
        return map.values();
    }
}
public class Son extends Father {
    //缩小输入参数范围
    public Collection doSomething(HashMap map){
        System.out.println("子类被执行...");
        return map.values();
    }
}
public class Client {
    public static void invoker(){
        //有父类的地方就有子类
        Father f= new Father();
        HashMap map = new HashMap();
        f.doSomething(map);
    }
    public static void main(String[] args) {
        invoker();
    }
}
```
上面的代码输出的结果是子类被执行, 而它并没有 override 父类的方法.
