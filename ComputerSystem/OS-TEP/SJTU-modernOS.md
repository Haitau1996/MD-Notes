# 现代操作系统 ： 原理与实现

## Chap 8: 同步
并行处理同—任务意味着对共享资源的并发访问，为了保证共享资源状态的正确性,需要正确地在这些子任务之间进行同步。为此抽象出同步原语(synchronization primitive) 供开发者使用， 在单核中因为存在线程切换也存在多个线程之间同步的需求。
### 互斥锁
在生产者-消费者模型中， 如果两个线程同时写入缓冲区， 就会导致数据覆盖：**这种正确性依赖于特定执行顺序的情况被称为竞争冒险(race hazard)**。  
最直接的避免办法就是**确保同一时刻只有一个线程能够对缓冲区进行操作**， 又被称为 **互斥访问**(mutual exclusion), 而保证互斥访问共享资源的代码区域被称为**临界区**(critical section), 如何通过设计协议来保证互斥访问临界区的问题就称 **临界区问题**。需要设计一个协议来保证临界区的互斥性：<div align=center><img src="https://i.imgur.com/7tIqaeI.png" width="35%"/></div>  
设计的算法应该满足以下条件：
1. **互斥访问**:在同一时刻最多只有—个线程可以执们临界区
2. **有限等待**:当一个线程申请进人临界区之后，必须在有限的时间内获得许可并进入临界区，不能无限等待。
3. **空闲让迸**:当没有线程在执行临界区代码时， 必须在申请进人临界区的线程中选择一个线程，允许其执行临界区代码，保证程序执了的进展。

#### 硬件实现:互斥锁
在单核环境中， 我们可以通过关闭中断来解决临界区问题， 关闭中断**意味着当前执行的线程不会被其他线程抢占**。在多核环境中， 关闭中断并不能阻塞其他核心中正在运行的线程， 因此在多核环境中， 关闭中断依旧存在临界区问题。

#### 软件实现： 皮特森算法
皮特森算法中有全局数组 flag 和全局变量 turn,<font color=pink>这里的代码中都是将 turn 设置为对方而非自己</font>,否则会出现两个线程同时进入临界区的情况。<div align=center><img src="https://i.imgur.com/Ch9PGt5.png" width="70%"/></div>
皮特森算法只能适用于访存操作严格按照程序顺序执行的情况， 现代体系结构为了性能会允许访存操作的乱序执行， 无法使用皮特森算法。 

#### 软硬件协同： 使用原子操作实现互斥锁
我们还可以利用硬件提供的**原子操作**（atomic operation）设计新的软件算法来解决临界区问题。