# 现代操作系统 ： 原理与实现
## Chap 1: 操作系统概述
什么是操作系统：
* 硬件角度： 管理硬件， 对硬件提供抽象
* 软件角度： 服务于应用（提供接口， 访问控制，交互）， 管理应用（进程管理， 调度）

### 操作系统接口
从应用的角度， 操作系统提供了不同层次的接口：系统调用接口， POSIX 接口和领域应用接口。<div align=center><img src="https://raw.githubusercontent.com/Haitau1996/picgo-hosting/master/img/20220512111259.png" width="40%"/></div>  
* 应用程序通过操作系统内核提供的接口（如系统调用）向内核申请服务
* 由于每个操作系统提供的系统调用各不相同， 为了一个应用程序在不同操作系统上的可移植性， 形成了一些可移植的接口
* 在POSIX或操作系统调用的基础上还可以封装面向不同领域的领域应用接口


## Chap 6: 操作系统调度
操作系统调度的目的是在有限的资源上， 通过对多个程序执行过程的管理， 尽可能满足系统和应用的指标(等待响应时间、完成时间、资源利用率、吞吐率...)。  
系统中的调度有很多类别，如 任务调度， I/O 调度，内存调度。这里主要关心的是任务调度， **进程是资源隔离的单位， 并不是执行的单位**， 一个进程可以有多个线程， 这些线程可以在不同的 CPU 核心上并行的地执行， 因此**线程才是调度器的调度对象**， Linux 中通常用==任务==(task)来描述线程。  
一般调度器通过维护==运行队列==(run queue) 的方式来管理任务， 它并非一定是一个 FIFO 队列（Linux 调度器使用红黑树实现）， 任务在触发一定条件会停止执行：
* 时间片耗尽
* 发起了 I/O 请求， 在 I/O 返回前不会继续执行
* 任务主动停止执行或者进入睡眠
* 任务被系统中断打断， 系统优先处理中断而暂缓执行

调度器设计的问题主要有两类：
* 调度器怎样做出决策？ 可以理解为调度指标是什么，如何考虑
* 调度器如何做出符合预期的决策

### 调度机制
进程可能处于不同的状态， 包括 **新生，就绪，运行， 阻塞**和**终止**。进程调度器根据职责不同分为长期、中期和短期调度。  
* 即使用户已经向操作系统提交了执行某个程序的请求，系统可能也不会立即处理该请求， 这个决策是由系统中的**长期调度**负责， 它像一个阀门，用于限制系统中真正被短期调度管理的进程数量，避免短期调度的开销过大。
* 当某个进程创建并被设置为 ready 之后， 就会由**短期调度**进一步管理该进程， 具体而言它主要负责进程在预备状态-运行状态-阻塞状态间的转换。
* 长期调度限制了进程数量， 但是使用内存仍然可能超过系统中内存总量， 这时候要由**中期调度**来负责， 它实际上是换页机制的—部分。<div align=center><img src="https://raw.githubusercontent.com/Haitau1996/picgo-hosting/master/img/20220511123051.png" width="70%"/></div>

### 单核调度策略


#### 调度指标
用户对于不同场景有不同的预期，常用的指标有几种类型：
* 与性能相关的**吞吐量,周转时间， 响应时间**
* 非性能指标 **公平性， 资源利用率**
* 特定场景的需求， 如终端设备的**能耗**， 实时任务的**实时性**

有的调度指标是和使用场景相关的：
* 有一类被称为批处理任务，如机器学习的训练， 执行时无需与用户交互，其目标就是尽可能快地完成,主要调度指标是任务处理的**吞吐量**（单位时间内处理的任务数量）尽可能高，调度需要让任务的**周转时间**（任务从被发起直至执行结束所需的时间）尽量短。  
* 计算机也要执行很多**交互式任务**， 如程序调试， 用户关心的是自己的请求（例如自己敲击键盘的输入）能否及时被处理， 这时候需要的是**响应时间**(任务从被发起直至第—次向用户返回输出以响应用户所需的时间)足够短，使用户获得良好的体验。  
* 在车载系统中， 系统还会被用于处理有截止时间要求的**实时任务**，在系统保证实时任务执行结果正确的同时，调度还必须让实时任务在截止时间前完成，即满足**实时性**。  
* 移动设备上的操作系统则尽可能降低**能耗**。  

而有的指标是所有场景共有的， 调度器应该尽可能地保证系统资源被充分利用，提高**资源利用率**； 在通常情况下, 应保证每个任务都有执行的可能, 即满足**公平性**; 调度器做出决策的时延应尽可能短, 降低**调度开销**。
### 调度机制

## Chap 8: 同步
并行处理同—任务意味着对共享资源的并发访问，为了保证共享资源状态的正确性,需要正确地在这些子任务之间进行同步。为此抽象出同步原语(synchronization primitive) 供开发者使用， 在单核中因为存在线程切换也存在多个线程之间同步的需求。
### 互斥锁
在生产者-消费者模型中， 如果两个线程同时写入缓冲区， 就会导致数据覆盖：**这种正确性依赖于特定执行顺序的情况被称为竞争冒险(race hazard)**。  
最直接的避免办法就是**确保同一时刻只有一个线程能够对缓冲区进行操作**， 又被称为 **互斥访问**(mutual exclusion), 而保证互斥访问共享资源的代码区域被称为**临界区**(critical section), 如何通过设计协议来保证互斥访问临界区的问题就称 **临界区问题**。需要设计一个协议来保证临界区的互斥性：<div align=center><img src="https://i.imgur.com/7tIqaeI.png" width="35%"/></div>  
设计的算法应该满足以下条件：
1. **互斥访问**:在同一时刻最多只有—个线程可以执们临界区
2. **有限等待**:当一个线程申请进人临界区之后，必须在有限的时间内获得许可并进入临界区，不能无限等待。
3. **空闲让迸**:当没有线程在执行临界区代码时， 必须在申请进人临界区的线程中选择一个线程，允许其执行临界区代码，保证程序执了的进展。

#### 硬件实现:互斥锁
在单核环境中， 我们可以通过关闭中断来解决临界区问题， 关闭中断**意味着当前执行的线程不会被其他线程抢占**。在多核环境中， 关闭中断并不能阻塞其他核心中正在运行的线程(恐龙书： 消息要传递到所有处理器，传递会延迟进入临界区，并降低系统效率)， 因此在多核环境中， 关闭中断依旧存在临界区问题。

#### 软件实现： 皮特森算法
皮特森算法中有全局数组 flag 和全局变量 turn,<font color=pink>这里的代码中都是将 turn 设置为对方而非自己</font>,否则会出现两个线程同时进入临界区的情况。<div align=center><img src="https://i.imgur.com/Ch9PGt5.png" width="70%"/></div>
皮特森算法只能适用于访存操作严格按照程序顺序执行的情况， 现代体系结构为了性能会允许访存操作的乱序执行， 无法使用皮特森算法。 

#### 软硬件协同： 使用原子操作实现互斥锁
我们还可以利用硬件提供的**原子操作**（atomic operation）设计新的软件算法来解决临界区问题。原子操作指的是不可被打断的—个或一系列操作，比较常见的有比较与置换(Compare And Swap, CAS)、拿取并累加(Fetch And Add, FAA) 等。