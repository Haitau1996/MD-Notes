# [Operating System : three easy pieces](http://pages.cs.wisc.edu/~remzi/OSTEP/)
inspired by the book written by [Remzi H. Arpaci-Dusseau](http://pages.cs.wisc.edu/~remzi/) and [Andrea C. Arpaci-Dusseau](http://pages.cs.wisc.edu/~dusseau/)

### Chap 1: About the Book
**虚拟化(virtualization)\并发(concurrency)和持久性(presitence)** 是操作系统中的三个关键概念, 理解后有助于帮助我们理解操作系统是如何工作的.学习这个课程,需要借助笔记和 __项目__ 理解巩固操作系统中的概念.

### Chap 2: Introduction to Operating System
有一类软件让程序运行变得容易, 允许程序共享内存,让程序能够和设备交互, 以及其他类似有趣的工作,要做到这点,操作系统需要用一种被称为虚拟化(virtualization)的通用技术: __将物理资源(内存/处理器/磁盘等)转化为更为通用\更强大且更利于使用的虚拟形式__. 每个CPU\内存和磁盘都是系统的资源,操作系统扮演的主要角色就是管理这些资源,做到高效或公平,或者实际上考虑其他许多可能的目标.

#### 虚拟化 CPU
从结果上看, 在硬件的帮助下, 操作系统负责提供一种假象, **系统拥有非常多的虚拟CPU**. <br>
一次运行多个程序可能会带来各种新的问题, 如两个程序要在特定的时间运行, 应该先运行哪一个. 这个问题需要由操作系统的 策略(policy) 来回答. 

#### 虚拟化内存
每个进程访问自己的私有虚拟空间, 操作系统以某种方式映射到机器的物理内存上.物理内存是有操作系统共享的资源, 这是如何完成的属于虚拟化的主题.

#### 并发
concurrency 指代一系列的问题, 他们在同时处理很多事情时出现并且必须解决. 并发问题不再局限于操作系统本身, 现代多线程程序也存在相同的问题. 例如两个线程共享一个计数器, 需要三步:
1. 将计数器值从内存加载到寄存器
2. 将该值递增
3. 将其保存回内存

而这三条指令并不是以原子方式执行(所有的指令一次执行), 因此可能造成混乱使得结果和我们希望的不同.

#### 持久性
在系统内存中, 数据容易丢失(DRAM 以 volatile 方式存储数值),因此我们需要硬件和软件来持久地存储数据. 操作系统中管理磁盘的软件通常称为文件系统(file system), 负责高效和可靠地方式将用户的任何文件存在在系统的磁盘上. 操作系统并不会为每个应用程序创建专用的虚拟磁盘, 而是经常需要共享文件中的信息. 

#### 设计目标
操作系统取得 CPU/内存 或磁盘等物理资源, 并对他们进行虚拟化. 它处理与并发相关的码放且棘手的问题, 它持久地存储文件从而使他们长期安全. 相关的目标如下:
1. 基本目标是建立一些抽象, 让系统方便和易于使用
2. 另外一个目标是提供高性能
3. 还有就是在应用程序之间以及 OS和应用程序之间提供保护
4. 操作系统也必须不间断运行

## 第一部分: 虚拟化
### Chap 4: 抽象 -- 进程
进程就是运行中的程序, 是一个正在运行的程序实例. 操作系统通过虚拟化 CPU 来提供这些假象, 具体而言就是 **让一个进程只运行一个时间片, 然后切换到其他进程, 提供存在多个虚拟CPU 的假象**, 这就是 **time sharing** of the CPU.潜在的开销就是性能损失, 想要实现得好就需要一些低级机制(**mechanisms**, 低级方法或协议,实现所需要的功能) 以及一些高级智能(其中一些以策略, policy, 的形式存在).

#### 抽象: 进程
操作系统为正在运行的程序提供的抽象, 就是进程, 一个进程就是一个正在运行的程序. 理解进程就需要理解其 **机器状态: 程序在运行中可以读取或者更新的内容**.
* 内存是机器状态的一个明显组成部分, 可以访问的内存被称为地址空间(address space)
* 另一个部分是**寄存器**: 其中包含一些特殊的寄存器,如 %rsp(stack pointer) 和相关的帧指针(frame pointer)用于管理函数参数栈/局部变量和返回地址, 程序计数器(Program Counter) 告诉我们即将执行哪个指令
* 最后包含经常访问持久存储设备

#### 进程 API
现代操作系统都以某种形式提供这些 API:
* 创建
* 销毁
* 等待
* 其他控制
* 状态

#### 进程创建: 更多细节
我们需要理解操作系统是如何启动并运行一个程序的:
1. 第一件事情就是将代码和所有的静态数据加载到内存
2. 此后操作系统在进行次进程之前还需要执行一些其他的操作, 例如为程序的运行时栈(run-time stack) 分配一些内存,也可能为程序的堆分配一些内存
3. 操作系统还将执行一些其他的初始化任务, 特别的 IO 相关的

#### 进程状态
简单来说, 进程可以出于下面三种状态之一:
* 运行: 在运行状态下, 处理器正在执行它的指令
* 就绪: 进程已经准备好运行, 但是操作系统选择不在此时运行
* 阻塞: 一个进程执行了某种操作(例如IO), 直到发生其他事件的时候才会准备运行

<div align=center><img src="https://gitee.com/Haitau1996/picture-hosting/raw/master/img/20210506165134.png"/></div>

#### 数据结构
操作系统也有一些关键的数据结构来跟踪各种相关的信息. 例如 xv6 使用一个 context 的结构体来保存寄存器的内容, 用于上下文切换. 

### Chap 5: 进程 API
UNIX 提供了创建新进程的方式, 通过系统调用 `fork()` 和 `exec()`, 还有一个系统调用 `wait()` 等待其创建的子进程执行完成. 
#### `fork()` 系统调用
下面的代码展示了 fork 是如何使用的:
```C++
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(int argc, char* argv[]){
    printf("hello world form pid %d \n", (int)getpid());
    int rc = fork();// 从这里开始有两个进程
    if(rc < 0){
        fprintf(stderr, "fork failed\n");
        exit(0);
    }else if(rc == 0){ // 子进程则进入这个代码块
        printf("hello I am a child %d\n", (int)getpid());
    }else {    // 父进程进入这个代码块
        printf("hello I am parent of %d with pid %d\n",rc, (int)getpid());
    }
    return 0;
}
```
```Shell
hello world form pid 992 
hello I am parent of 993 with pid 992
hello I am a child 993
```
在 UNIX 系统中, 如果要操作某个进程, 就需要使用 `PID` 来指明. 使用 `fork()` 调用新创建的进程几乎与调用进程完全一样, 它拥有自己的地址空间,寄存器,程序计数器, 但是从 `fork()` 返回的值是不同的, 父进程获得的是子进程的 PID, 而子进程获得的是 0. 可以容易地理解, 两者的输出顺序是不确定的. 

#### `wait()` 系统调用
我们可以对上面的代码稍加修改, 加入 `<sys/wait.h>` 头文件, 在父进程执行的块中加入一行:
```C++
else{
    int wc = wait(NULL);
    printf("hello from parent of %d with %d \n",rc, (int)getpid());
}
```
这是父进程就会等到子进程运行完成之后再运行, 这时候 `wait()` 返回, 接着父进程才输出自己的信息.

#### `exec()` 系统调用
`exec()` 系统调用是创建进程 API 的一个重要部分, 可以让父进程与子进程执行执行不同的程序. 例如我们修改子进程的代码:
```C++
    char* myArgs[3];
    myArgs[0] = strdup("wc");
    myArgs[1] = strdup("wait.c");
    myArgs[2] = NULL;
    execvp(myArgs[0],myArgs);//调用成功就不再返回
    printf("this line will never come out\n");
```
结果就是在子进程中调用字符计数器 wc, 对文件 wait.c 做计数. `exec()` 从可执行程序中加载代码和静态数据, 并且覆盖自己的代码段, 堆/栈 以及其他内存空间也会被重新初始化, 操作系统会执行唉程序, 对 `exec` 的调用永远不会返回.

#### 为何如此设计 API
事实证明, 分离 fork 和 exec 的做法在构建 UNIX Shell 的时候非常有用, 给了 shell 在执行 fork 之后 exec 之前的运行代码的机会, 这些代码可以在运行新程序之前改变环境, 从而实现一系列有趣的功能. 例如 UNIX 中管道的实现, 用的是 `pipe()` 系统调用, 一个进程的输出被链接到一个内核管道上(队列), 另一个进程的输入也被链接到同一个管道上. 

### Chap 6: 受限直接执行(Limited Direct Execution)
虚拟化 CPU 的思想很简单: 运行一个进程一段时间, 然后运行另一个进程, 如此轮换. 构建如此虚拟化机制存在两个挑战:
* 性能
* 控制权

构建操作系统的一个主要挑战就是**在保持控制权的同时获得高性能**.
#### 基本技巧: 受限直接执行
直接执行的概念很好理解: 只需直接在 CPU 上运行程序即可.
<div align=center><img src="https://gitee.com/Haitau1996/picture-hosting/raw/master/img/20210519092134.png"/></div>

但是这在我们虚拟化 CPU 时产生了一些问题:
* 如果我们只运行一个程序, 操作系统怎么确保程序不做任何我们不希望它做的事同时依然高效运行
* 当我们运行一个进程时, 操作系统如何让它停下来并切换到另一个进程, 从而实现虚拟化 CPU 所需的时分共享

#### 受限制的操作
在 CUP 上运行会带来一个问题, 如果进程希望执行某种受限操作(如 IO/申请内存), 应该如何做?<br>
**硬件通过提供不同的执行模式来协助操作系统**, 在用户模式下, 应用程序不能完全访问硬件资源, 在内核模式下, 操作系统可以访问机器的全部资源. 还提供了陷入(trap)内核和从陷进返回(return-from-trap)到用户模式程序的说明, 以及一些指令, 让操作系统告诉硬件陷阱表(trap table) 在内存中的位置.<br>
现代操作系统提供了用户程序执行系统调用的能力, 允许内核小心地向用户程序暴露某些关键功能(文件访问, 创建销毁进程, 进程间通信, 分配内存 etc.). 执行陷阱时, 硬件要小心, 必须保存足够的调用者寄存器, 以便在操作系统发出从陷阱返回指令时能正确返回. <br>
系统调用看起来像是过程调用, 是因为它是一个过程调用, 但是隐藏在过程调用的内部是著名的陷阱指令. 剩下的问题就是陷进如何知道在 OS 内运行哪些代码, **内核通过在启动时设置陷进表来实现**. 机器启动时, 在特权模式下执行, 告诉硬件在发生某些异常时间时需要运行哪些代码, 发生异常时通过特殊的指令通知硬件这些处理程序的位置. 一旦硬件被通知, 他就会记住这些处理程序的位置, 直到下次一重新启动机器.<br>
能够执行特权指令告诉硬件缺陷表位置是一个非常强大的功能, 这也是一项特权操作, 硬件会阻止用户模式下执行. 
<div align=center><img src="https://i.loli.net/2021/05/19/oz39teKy61Ans52.png"/></div>

#### 进程之间的切换
有一个关键的问题是 : 操作系统如何重新获取 CPU 的控制权, 以便它可以在进程之间切换.

##### 协作方式: 等待系统调用
协作风格下, 操作系统相信系统的进程会合理运行, 运行过长时间的进程会被假定暂时放弃 CPU, 以便操作系统可以运行其他任务. 而进程通过进行系统调用, 将 CPU 控制权转移给操作系统. 如果应用执行了某些非法操作, 也会将控制权转移给操作系统. 

##### 非协作方式: 操作系统进行控制
在协作方式中, 进程陷入无限循环时, 唯一的解决办法就是重启计算机. 在没有协作的方式下, 获得控制权的方式很简单: **时钟中断**. 和前面讨论系统调用一样, 操作系统必须通知硬件哪些代码在发生时钟中断时运行. 

##### 保存和恢复上下文
无论通过系统调用协作还是时钟中断强制执行, 都必须决定是继续运行当前程序还是切换到另一个进程, 决定由调度程序(scheduler)作出. 决定进行切换, OS 就会执行一些低层代码(上下文切换, context switch): 系统为当前正在执行的进程保存一些寄存器值, 并且为即将执行的进程恢复一些寄存器的值, 并且切换内核栈. 
<div align=center><img src="https://i.loli.net/2021/05/19/n4GxYWIbdCLaHOZ.png"/></div>

需要注意的是由两种类型的寄存器保存/恢复:
* 发生时钟中段的时候, 运行几次呢很难过的用户寄存器由硬件隐式保存, 使用该今晨的内核栈
* 操作系统决定从 A 切换到 B, 内核寄存器被软件明确保存, 但是这种刚好被存储在该进程结构的内存中

```x86asm
# void swt ch ( struct context ** old, st ruct context *new)
#
# S av e c urre n t regi s ter co ntext in old
# and then load register context from new.
.globl swtch
swtch:
# Sav e old regi s ter s
movl 4(%esp), %eax # put old ptr into eax
popl 0 (%eax)	# save the old IP
movl %esp, 4 (:%eax) # and stack
movl %ebx, 8 (:%eax) # and other registers
movl %ecx, 12 (%eax)
movl %edx, 16( %eax)
movl %esi, 20(%eax)
movl %edi, 24(%eax)
movl %ebp, 28(%eax)

# Loa d new regi s ter s
movl 4 (%esp), %eax # put new ptr into eax
movl 28 ( %eax) , :%ebp # restore other registers
movl 24(%eax), %edi
movl 20(%eax), %esi
movl 16(%eax), %edx
movl 12(%eax), %ecx
movl 8(%eax), %ebx
movl 4 (%eax), %esp # stack is switched here
pushl 0 (%e = z)	# return addr put in place
ret	# finally return into new ctxt
```

#### 担心并发吗
操作系统可能简单决定, 在中断处理时禁用中断, 但是这可能丢失中断, 在技术上是不好的. 操作系统开发了很多复杂的家锁方案, 以保护内部数据结构的并发访问, 使得多个活动可以同时在内核中进行. 这可能导致各种有趣并且难以发现的错误. 

#### 小结
实现 CPU 虚拟化的关键底层机制, 受限直接执行, 基本思路很简单: 就让你想运行的程序在 CPU 上运行, 但首先确保设置好硬件, 一遍没有操作系统帮助的情况下限制进程可以执行的操作. 下一个问题就是: 在特定的时间, 我们应该运行哪个进程.