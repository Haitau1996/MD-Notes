# [Operating System : three easy pieces](http://pages.cs.wisc.edu/~remzi/OSTEP/)
inspired by the book written by [Remzi H. Arpaci-Dusseau](http://pages.cs.wisc.edu/~remzi/) and [Andrea C. Arpaci-Dusseau](http://pages.cs.wisc.edu/~dusseau/)

### Chap 1: About the Book
**虚拟化(virtualization)\并发(concurrency)和持久性(presitence)** 是操作系统中的三个关键概念, 理解后有助于帮助我们理解操作系统是如何工作的.学习这个课程,需要借助笔记和 __项目__ 理解巩固操作系统中的概念.

### Chap 2: Introduction to Operating System
有一类软件让程序运行变得容易, 允许程序共享内存,让程序能够和设备交互, 以及其他类似有趣的工作,要做到这点,操作系统需要用一种被称为虚拟化(virtualization)的通用技术: __将物理资源(内存/处理器/磁盘等)转化为更为通用\更强大且更利于使用的虚拟形式__. 每个CPU\内存和磁盘都是系统的资源,操作系统扮演的主要角色就是管理这些资源,做到高效或公平,或者实际上考虑其他许多可能的目标.

#### 虚拟化 CPU
从结果上看, 在硬件的帮助下, 操作系统负责提供一种假象, **系统拥有非常多的虚拟CPU**. <br>
一次运行多个程序可能会带来各种新的问题, 如两个程序要在特定的时间运行, 应该先运行哪一个. 这个问题需要由操作系统的 策略(policy) 来回答. 

#### 虚拟化内存
每个进程访问自己的私有虚拟空间, 操作系统以某种方式映射到机器的物理内存上.物理内存是有操作系统共享的资源, 这是如何完成的属于虚拟化的主题.

#### 并发
concurrency 指代一系列的问题, 他们在同时处理很多事情时出现并且必须解决. 并发问题不再局限于操作系统本身, 现代多线程程序也存在相同的问题. 例如两个线程共享一个计数器, 需要三步:
1. 将计数器值从内存加载到寄存器
2. 将该值递增
3. 将其保存回内存

而这三条指令并不是以原子方式执行(所有的指令一次执行), 因此可能造成混乱使得结果和我们希望的不同.

#### 持久性
在系统内存中, 数据容易丢失(DRAM 以 volatile 方式存储数值),因此我们需要硬件和软件来持久地存储数据. 操作系统中管理磁盘的软件通常称为文件系统(file system), 负责高效和可靠地方式将用户的任何文件存在在系统的磁盘上. 操作系统并不会为每个应用程序创建专用的虚拟磁盘, 而是经常需要共享文件中的信息. 

#### 设计目标
操作系统取得 CPU/内存 或磁盘等物理资源, 并对他们进行虚拟化. 它处理与并发相关的码放且棘手的问题, 它持久地存储文件从而使他们长期安全. 相关的目标如下:
1. 基本目标是建立一些抽象, 让系统方便和易于使用
2. 另外一个目标是提供高性能
3. 还有就是在应用程序之间以及 OS和应用程序之间提供保护
4. 操作系统也必须不间断运行

## 第一部分: 虚拟化
### Chap 4: 抽象 -- 进程
进程就是运行中的程序, 是一个正在运行的程序实例. 操作系统通过虚拟化 CPU 来提供这些假象, 具体而言就是 **让一个进程只运行一个时间片, 然后切换到其他进程, 提供存在多个虚拟CPU 的假象**, 这就是 **time sharing** of the CPU.潜在的开销就是性能损失, 想要实现得好就需要一些低级机制(**mechanisms**, 低级方法或协议,实现所需要的功能) 以及一些高级智能(其中一些以策略, policy, 的形式存在).

#### 抽象: 进程
操作系统为正在运行的程序提供的抽象, 就是进程, 一个进程就是一个正在运行的程序. 理解进程就需要理解其 **机器状态: 程序在运行中可以读取或者更新的内容**.
* 内存是机器状态的一个明显组成部分, 可以访问的内存被称为地址空间(address space)
* 另一个部分是**寄存器**: 其中包含一些特殊的寄存器,如 %rsp(stack pointer) 和相关的帧指针(frame pointer)用于管理函数参数栈/局部变量和返回地址, 程序计数器(Program Counter) 告诉我们即将执行哪个指令
* 最后包含经常访问持久存储设备

#### 进程 API
现代操作系统都以某种形式提供这些 API:
* 创建
* 销毁
* 等待
* 其他控制
* 状态

#### 进程创建: 更多细节
我们需要理解操作系统是如何启动并运行一个程序的:
1. 第一件事情就是将代码和所有的静态数据加载到内存
2. 此后操作系统在进行次进程之前还需要执行一些其他的操作, 例如为程序的运行时栈(run-time stack) 分配一些内存,也可能为程序的堆分配一些内存
3. 操作系统还将执行一些其他的初始化任务, 特别的 IO 相关的

#### 进程状态
简单来说, 进程可以出于下面三种状态之一:
* 运行: 在运行状态下, 处理器正在执行它的指令
* 就绪: 进程已经准备好运行, 但是操作系统选择不在此时运行
* 阻塞: 一个进程执行了某种操作(例如IO), 直到发生其他事件的时候才会准备运行

<div align=center><img src="https://gitee.com/Haitau1996/picture-hosting/raw/master/img/20210506165134.png"/></div>

#### 数据结构
操作系统也有一些关键的数据结构来跟踪各种相关的信息. 例如 xv6 使用一个 context 的结构体来保存寄存器的内容, 用于上下文切换. 

### Chap 5: 进程 API
UNIX 提供了创建新进程的方式, 通过系统调用 `fork()` 和 `exec()`, 还有一个系统调用 `wait()` 等待其创建的子进程执行完成. 
#### `fork()` 系统调用
下面的代码展示了 fork 是如何使用的:
```C++
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(int argc, char* argv[]){
    printf("hello world form pid %d \n", (int)getpid());
    int rc = fork();// 从这里开始有两个进程
    if(rc < 0){
        fprintf(stderr, "fork failed\n");
        exit(0);
    }else if(rc == 0){ // 子进程则进入这个代码块
        printf("hello I am a child %d\n", (int)getpid());
    }else {    // 父进程进入这个代码块
        printf("hello I am parent of %d with pid %d\n",rc, (int)getpid());
    }
    return 0;
}
```
```Shell
hello world form pid 992 
hello I am parent of 993 with pid 992
hello I am a child 993
```
在 UNIX 系统中, 如果要操作某个进程, 就需要使用 `PID` 来指明. 使用 `fork()` 调用新创建的进程几乎与调用进程完全一样, 它拥有自己的地址空间,寄存器,程序计数器, 但是从 `fork()` 返回的值是不同的, 父进程获得的是子进程的 PID, 而子进程获得的是 0. 可以容易地理解, 两者的输出顺序是不确定的. 

#### `wait()` 系统调用
我们可以对上面的代码稍加修改, 加入 `<sys/wait.h>` 头文件, 在父进程执行的块中加入一行:
```C++
else{
    int wc = wait(NULL);
    printf("hello from parent of %d with %d \n",rc, (int)getpid());
}
```
这是父进程就会等到子进程运行完成之后再运行, 这时候 `wait()` 返回, 接着父进程才输出自己的信息.

#### `exec()` 系统调用
`exec()` 系统调用是创建进程 API 的一个重要部分, 可以让父进程与子进程执行执行不同的程序. 例如我们修改子进程的代码:
```C++
        char* myArgs[3];
        myArgs[0] = strdup("wc");
        myArgs[1] = strdup("wait.c");
        myArgs[2] = NULL;
        execvp(myArgs[0],myArgs);//调用成功就不再返回
        printf("this line will never come out\n");
```
结果就是在子进程中调用字符计数器 wc, 对文件 wait.c 做计数. `exec()` 从可执行程序中加载代码和静态数据, 并且覆盖自己的代码段, 堆/栈 以及其他内存空间也会被重新初始化, 操作系统会执行唉程序, 对 `exec` 的调用永远不会返回.

#### 为何如此设计 API
事实证明, 分离 fork 和 exec 的做法在构建 UNIX Shell 的时候非常有用, 给了 shell 在执行 fork 之后 exec 之前的运行代码的机会, 这些代码可以在运行新程序之前改变环境, 从而实现一系列有趣的功能. 例如 UNIX 中管道的实现, 用的是 `pipe()` 系统调用, 一个进程的输出被链接到一个内核管道上(队列), 另一个进程的输入也被链接到同一个管道上. 