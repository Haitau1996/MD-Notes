# [CS162:Operating System and Systems Programming](https://inst.eecs.berkeley.edu/~cs162/fa20/)
## Lecture 1 - what is an operating system
因特网作为最伟大的人工制品，其组件在不同的时间尺度运行：<div align=center><img src="https://raw.githubusercontent.com/Haitau1996/picgo-hosting/master/img/20220110161033.png" width="60%"/></div>

操作系统是它们的核心：
* 使得基础技术的惊人进步可以用于快速演化的应用程序主体
  * 给应用程序提供了**一致的抽象**（consistent abstractions），即使面对不同的硬件
  * 在多个应用程序中管理**资源的共享**（sharing of resources）
* 主要的组成部分包括
  * 进程
  * 线程，并发，调度
  * 内存空间
  * ...

什么是操作系统？  
* 没有广泛接受的定义
* the kernel:the one program running at all times on the computer
  * 其他的东西要么是系统程序（和操作系统一起分发）要么是应用程序
* 一种定义： 是给应用程序提供硬件资源访问的特殊层级的软件
  * 给复杂的硬件提供便利的抽象
  * 提供共享资源受保护的访问
  * 安全和身份验证
  * 通信<div align=center><img src="https://raw.githubusercontent.com/Haitau1996/picgo-hosting/master/img/20220112162937.png" width="40%"/></div>

如何才能称为是系统：
* 多个相互关联的部分
  * 每个部分可能和其他的相互作用
* 健壮性要求工程思维
  * 谨慎的错误处理
  * 把电脑当成是具体的机器， 考虑其限制和可能的错误

从软硬件接口的角度考虑：操作系统给应用程序提供硬件细节的抽象。
<div align=center><img src="https://raw.githubusercontent.com/Haitau1996/picgo-hosting/master/img/20220112164038.png" width="60%"/></div>
 
* 操作系统更像是一个魔术师,为物理资源提供简单易用的抽象
  * 无限的内存， 专用的机器（其实可能是共享的）
  * 高层级的对象： 文件、用户、消息
  * 掩盖限制， 虚拟化<div align=center><img src="https://raw.githubusercontent.com/Haitau1996/picgo-hosting/master/img/20220112165238.png" width="80%"/></div>

  * 应用程序的“machine”实际上是 OS 提供的进程抽象
  * 每个运行中程序都在它自己的进程上运行
  * 进程提供比原硬件更好的接口
  * 进程是 OS 提供带有受限权力的执行环境，其中包含：
    * 地址空间：一块受保护的内存
    * 一个或者多个控制执行的线程
    * 其他与它关联的系统状态，如打开的文件， 打开的 sockets
* Referee(裁判， 仲裁者)
  * 管理 protection, isolation and sharing of resources<div align=center><img src="https://raw.githubusercontent.com/Haitau1996/picgo-hosting/master/img/20220112171552.png" width="60%"/></div>
* Glue(胶水)
  * 提供 common services
  * 通常是通过库来提供

## Lecture 02 - Four Fundamental OS Concepts
OS 抽象底层的硬件抽象以管理复杂性，<div align=center><img src="https://raw.githubusercontent.com/Haitau1996/picgo-hosting/master/img/20220112234543.png" width="40%"/></div>

* 处理器 ➡️ 线程（thread）
* 内存 ➡️ 地址空间
* 硬盘 ➡️ 文件
* 网络 ➡️ Sockets
* 机器 ➡️ 进程（processes）

因此对于任意的 OS 领域，我们可以考虑下面两个问题：
* 需要应对怎样的硬件接口？ （physical reality）
* 需要提供怎样的软件接口？ （nicer abstraction）

四个重要的 OS 概念：
* 线程：执行的上下文
  * 完整描述程序的状态
  * 有程序计数器，寄存器， 执行标志，栈
* 地址空间(可能有翻译机制)
  * 程序可以获取的内存地址集合，
* 进程(process): 一个正在运行的程序实例
* 双模式操作、保护

指令的 fetch/Decode/Execute 循环：<div align=center><img src="https://raw.githubusercontent.com/Haitau1996/picgo-hosting/master/img/20220113000129.png" width="40%"/></div>

### Thread of Control
* 线程是单个独立的执行上下文环境， 相当于上面的 fetch/decode/Execute loop 的虚拟化版本
* 当线程**驻留**(resident)在处理器寄存器中的时候， 它正在处理器中执行
* 驻留意味着寄存器持有该线程的根状态（上下文）
  * 包括了程序计数器(PC)寄存器 和正在执行的指令
    * PC 指向内存中要运行的下一条指令
    * 指令存放在内存中
  * 包括即将进行计算的立即数（可能是值本身或者指针）
  * 栈指针存放者栈顶的地址
  * 其他的线程则放在内存中
* 一个线程在没有加载到处理器中的时候被称为暂停(suspended)
  * 处理器的状态指向其他线程

从硬件的视角看程序的执行过程：<div align=center><img src="https://raw.githubusercontent.com/Haitau1996/picgo-hosting/master/img/20220113001607.png" width="40%"/></div>

假设我们只有一个处理器， 我们应该怎样提供多出处理器的假象：<div align=center><img src="https://raw.githubusercontent.com/Haitau1996/picgo-hosting/master/img/20220113002124.png" width="30%"/></div>
* 时分复用(multiplex in time)
* 线程实际上是虚拟的处理器<div align=center><img src="https://raw.githubusercontent.com/Haitau1996/picgo-hosting/master/img/20220113002307.png" width="40%"/></div>
* 因此线程（虚拟的处理器）中要有下面的内容：
  * PC, stack pointer
  * 寄存器
* 线程在哪里？
  * 运行在实际的内核中或者
  * 保存在一块内存中（被称为 TCB, Thread Control Block）
* 在线程之间切换的过程中， 发生了上下文切换
  * OS 正常运行
  * 将 PC,SP... 等放到 vCPU1 的 TCB 中
  * 从 vCPU2 的 TCB 中加载 PC,SP..., 跳转到 PC 的指令上
* 触发切换的机制
  * 计时器，voluntary yield, I/O ...

线程控制块（TCB）保存了线程不再运行时的寄存器内容， For now, 可以认为它们保存在 kernel 中。

### 地址空间
地址空间 👉 可访问的空间集 + 与之关联的状态。我们在地址上读写时， 很多事情都可能发生：
* 可能像正常的内存一样行为
* 可能忽略写操作
* 可能导致 I/O （memory-mapped I/O）
* 可能导致异常
* 可能和其他的程序通讯

<div align=center><img src="https://raw.githubusercontent.com/Haitau1996/picgo-hosting/master/img/20220113005310.png" width="50%"/></div>
不同类型的数据放在地址空间的不同区域：

* 程序放置于 code segment 中
* 全局变量， 静态变量，字符串字面值等放置在 Static Data segment 中
* 局部变量放在 stack segment 中
* malloc 等调用产生的变量放置在 heap 中

过去简单的 multiprogramming 模型， 每个 thread 都可以读写内存（可能是其他 thread 的内存，也可能是 OS 的）， 这带来很高的风险。  
操作系统必须在用户程序面前保护自身：
* 可靠性： 损害操作系统的程序自身会崩溃
* 安全性： 限制 threads 可以做的范围
* 隐私性： 限制每个 thread 智能访问有权限的数据
* 公平性： 每个 thread 智能占有合理范围的计算机资源

OS 必须保证用户不受其他用户侵害：
* 保证一个用户的 threads 不会被其他用户的 threads 影响

#### 简单的保护： Base and Bound(B&B)
<div align=center><img src="https://raw.githubusercontent.com/Haitau1996/picgo-hosting/master/img/20220113210947.png" width="60%"/></div>

Simple Protection 中用的依旧是物理地址， 加载的时候会做 address translation, 硬件会把指针和 base 和 bound 两个值做快速的比较。
* 提供了 OS 保护和程序的隔离
* 需要重定位加载器
* 地址路径上没有加法(addition)

#### 带有 Base 和 Bound 的简单地址转换
<div align=center><img src="https://raw.githubusercontent.com/Haitau1996/picgo-hosting/master/img/20220113211900.png" width="60%"/></div>

* 硬件重定位
* 同样提供了 OS 保护和程序的隔离

#### 另一种思路： 地址空间转换
<div align=center><img src="https://raw.githubusercontent.com/Haitau1996/picgo-hosting/master/img/20220113212233.png" width="50%"/></div>

更进一步的做法就是将整个虚拟地址空间分割成等尺寸的块(paged virtual address space)
* 所有的页都是相同的尺寸， 更方便地放在内存中
* 硬件使用**页表**(page table)来翻译地址
  * 每页有不同的 base
  * bound 就是页的大小
  * 特定的硬件寄存器可以存放页表的指针
  * 可以将内存当成是 page size 的帧， 可以将任意 page 放入任意帧<div align=center><img src="https://raw.githubusercontent.com/Haitau1996/picgo-hosting/master/img/20220113212910.png" width="80%"/></div>

### 进程
定义： 具有受限制权限的执行环境
* 有一个或者多个线程的受保护地址空间
* 自有的内存（地址空间）
* 自有的文件描述符， 文件系统内容
* 封装了一个或者多个**共享 process resources** 的线程

应用程序被当做进程执行：
* 复杂的程序可能 fork/exec 子进程

使用进程的原因：
* 进程间相互保护
* 保护 OS
* 进程提供了内存保护

进程权衡效率和保护
* 同一个进程间相互通讯比较容易
* 进程间的相互通讯要复杂很多

<div align=center><img src="https://raw.githubusercontent.com/Haitau1996/picgo-hosting/master/img/20220113213812.png" width="50%"/></div>

* 线程封装了并发
  * 是主动的部件
* 地址空间封装了保护
  * 是被动的部件
  * 防止 buggy 程序损害操作系统
* 为什么在一个地址空间中要有多个 thread
  * 并行： 利用真实硬件的并行性
  * 并发： 方便同时处理 I/O 和其他事件

从机制上， 我们需要提供优先级， 不然一个进程可能改变自己的 page table pointer.

### 双模式操作
**硬件**提供最少两个模式（最小一个模式位）：
1. 内核态
2. 用户态

某些操作是禁止在用户态运行
* 更改页表指针、禁用中断、直接与硬件交互、写入内核内存 
<div align=center><img src="https://raw.githubusercontent.com/Haitau1996/picgo-hosting/master/img/20220113214900.png" width="70%"/></div>

严格控制用户态和内核态之间的切换（仅限于系统调用，中断，异常），例如 unix 的系统结构：<div align=center><img src="https://raw.githubusercontent.com/Haitau1996/picgo-hosting/master/img/20220113214944.png" width="70%"/></div>

<div align=center><img src="https://raw.githubusercontent.com/Haitau1996/picgo-hosting/master/img/20220113215415.png" width="60%"/></div><div align=center><img src="https://raw.githubusercontent.com/Haitau1996/picgo-hosting/master/img/20220113215505.png" width="60%"/></div>

有三种方式实现用户态到内核态的转换：
* 系统调用， 如进程要求系统服务(e.g., exit), 调用进程外的函数。。。
* 中断， 如 计时器，I/O 操作
* 异常或陷阱

## Lecture 03 - Abstraction 1： Threads and Processes, A quick Intro
这部分的主要目标是介绍 Thread 抽象：
* 什么是 thread
  * 什么不是 
* 为什么 thread 重要(motivation)
* 怎样使用 thread 编程
* thread 的替代品

<div align=center><img src="https://raw.githubusercontent.com/Haitau1996/picgo-hosting/master/img/20220113225909.png" width="60%"/></div>
前面提到的地址空间的概念， 其中的 translation map 由硬件提供， 而操作系统负责它的配置， 这种转换机制提供了保护功能。

### 什么是 thread
* 之前的定义：**单独的执行上下文**
* 它提供这样的抽象： 代表**独立可调度任务**的单个执行序列。
* threads 是一种并发机制(overlapping execution)
  * 此外它们也可以并行执行(simultaneous execution)
* 保护是和它无关的概念
  * 一个 protection domain 可能包含一个或者多个 thread

### thread 的动机
* 操作系统必须能够同时处理多个事情(multiple things at once, MTAO)
  * 进程， 中断， 后台的系统维护
* 网络服务器也必须处理 MTAO
  * 同时处理过个连接
* 并行程序必须处理 MTAO
  * 以实现更高的性能
* 有用户界面的程序经常需要处理 MTAO
  * 在进行计算时实现用户响应 
* 网路和硬盘相关的程序也应该处理 MTAO
  * 获取或者通信过程中有一系列的步骤，降低延迟

**Threads 可用于处理 MTAO**:
* 它是 OS 提供的并发单元
* 每个 threads 可以表示一个事情或者一个任务

和 multiprocessing 和 multiprogramming 相关的概念：
* Multiprocessing: Multiple CPUs(cores)
* Multiprogramming: Multiple jobs/processes
* Multithreading: Multiple threads/processes<div align=center><img src="https://raw.githubusercontent.com/Haitau1996/picgo-hosting/master/img/20220114145020.png" width="60%"/></div>

两个 threads 并发执行意味着：
* 调度器可以自由地以任何顺序或交错运行线程
* 线程可以执行到结束或者以大的代码块、小的代码块在时间切片中运行

因此并发并不是并行：
* 并发是能够 handling multiple things at once (MTAO)
* 并行是能同时做多个事情(simultaneously)
* 例如， 两个运行在一个 one-core 系统中的 thread 就是并发地执行， 但是不是并行
  * 每个 thread 处理一件事情
  * 但是两个 thread 并不需要 execute simultaneously 
    ```C++
    int main() {
      ComputePI(“pi.txt”);
      PrintClassList(“classlist.txt”);
    }
    int main() {
        create_thread(ComputePI, “pi.txt”);
        create_thread(PrintClassList, “classlist.txt”);
    }
    ```
    在第一个例子中， 因为 $\pi$ 的计算永远不会结束， 因此永远不会进入打印的函数。引入 thread 后， 调度器就可以让两个函数交替运行。
    * 给出有额外的 CPU 在运行第二个过程的错觉<div align=center><img src="https://raw.githubusercontent.com/Haitau1996/picgo-hosting/master/img/20220114150434.png" width="50%"/></div>

另一个实用的动机是 计算/IO 重叠：在单独的线程中处理 IO 可以避免阻塞其他计算过程。<div align=center><img src="https://raw.githubusercontent.com/Haitau1996/picgo-hosting/master/img/20220114151254.png" width="50%"/></div>

#### Thread 屏蔽 I/O 延迟
一个 thread 可能有三种状态：
* running
* ready : 可以运行， 但是当下没有运行
* blocked: 无法运行

如果一个 thread 在等待 I/O 结束， 操作系统会将它标志为 BLOCKED, 一旦 I/O 完成， OS 会将它标志为 READY。<div align=center><img src="https://raw.githubusercontent.com/Haitau1996/picgo-hosting/master/img/20220114151809.png" width="50%"/></div>

因此， 在涉及 I/O 或者需要大量计算的工作时候， 需要将它和需要快速响应的工作分开到不同的 threads 中：
```C++
int main() {
    create_thread(ReadLargeFile, “pi.txt”);
    create_thread(RenderUserInterface);
}
```

### Multithreaded 程序
#### 系统调用
<div align=center><img src="https://raw.githubusercontent.com/Haitau1996/picgo-hosting/master/img/20220114154521.png" width="60%"/></div>

很多时候系统调用隐藏在编程的接口中
* 系统库提供 system call
* 编程语言的运行时使用系统库<div align=center><img src="https://raw.githubusercontent.com/Haitau1996/picgo-hosting/master/img/20220114155009.png" width="50%"/></div>

#### OS 库的线程 API : pthread
* `int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
                      void *(*start_routine)(void*), void *arg);`
    实际做的事情就是创建一个 thread, 然后使用 `arg` 为参数运行 `start_routine`
* `void pthread_exit(void *value_ptr);`
* `int pthread_join(pthread_t thread, void **value_ptr);`

