# [CS162:Operating System and Systems Programming](https://inst.eecs.berkeley.edu/~cs162/fa20/)
# Lecture 1: what is an operating system
因特网作为最伟大的人工制品，其组件在不同的时间尺度运行：<div align=center><img src="https://raw.githubusercontent.com/Haitau1996/picgo-hosting/master/img/20220110161033.png" width="60%"/></div>

操作系统是它们的核心：
* 使得基础技术的惊人进步可以用于快速演化的应用程序主体
  * 给应用程序提供了**一致的抽象**（consistent abstractions），即使面对不同的硬件
  * 在多个应用程序中管理**资源的共享**（sharing of resources）
* 主要的组成部分包括
  * 进程
  * 线程，并发，调度
  * 内存空间
  * ...

什么是操作系统？  
* 没有广泛接受的定义
* the kernel:the one program running at all times on the computer
  * 其他的东西要么是系统程序（和操作系统一起分发）要么是应用程序
* 一种定义： 是给应用程序提供硬件资源访问的特殊层级的软件
  * 给复杂的硬件提供便利的抽象
  * 提供共享资源受保护的访问
  * 安全和身份验证
  * 通信<div align=center><img src="https://raw.githubusercontent.com/Haitau1996/picgo-hosting/master/img/20220112162937.png" width="40%"/></div>

如何才能称为是系统：
* 多个相互关联的部分
  * 每个部分可能和其他的相互作用
* 健壮性要求工程思维
  * 谨慎的错误处理
  * 把电脑当成是具体的机器， 考虑其限制和可能的错误

从软硬件接口的角度考虑：操作系统给应用程序提供硬件细节的抽象。
<div align=center><img src="https://raw.githubusercontent.com/Haitau1996/picgo-hosting/master/img/20220112164038.png" width="60%"/></div>
 
* 操作系统更像是一个魔术师,为物理资源提供简单易用的抽象
  * 无限的内存， 专用的机器（其实可能是共享的）
  * 高层级的对象： 文件、用户、消息
  * 掩盖限制， 虚拟化<div align=center><img src="https://raw.githubusercontent.com/Haitau1996/picgo-hosting/master/img/20220112165238.png" width="80%"/></div>

  * 应用程序的“machine”实际上是 OS 提供的进程抽象
  * 每个运行中程序都在它自己的进程上运行
  * 进程提供比原硬件更好的接口
  * 进程是 OS 提供带有受限权力的执行环境，其中包含：
    * 地址空间：一块受保护的内存
    * 一个或者多个控制执行的线程
    * 其他与它关联的系统状态，如打开的文件， 打开的 sockets
* Referee(裁判， 仲裁者)
  * 管理 protection, isolation and sharing of resources<div align=center><img src="https://raw.githubusercontent.com/Haitau1996/picgo-hosting/master/img/20220112171552.png" width="60%"/></div>
* Glue(胶水)
  * 提供 common services
  * 通常是通过库来提供

# Lecture 02: Four Fundamental OS Concepts
OS 抽象底层的硬件抽象以管理复杂性，<div align=center><img src="https://raw.githubusercontent.com/Haitau1996/picgo-hosting/master/img/20220112234543.png" width="40%"/></div>

* 处理器 ➡️ 线程（thread）
* 内存 ➡️ 地址空间
* 硬盘 ➡️ 文件
* 网络 ➡️ Sockets
* 机器 ➡️ 进程（processes）

因此对于任意的 OS 领域，我们可以考虑下面两个问题：
* 需要应对怎样的硬件接口？ （physical reality）
* 需要提供怎样的软件接口？ （nicer abstraction）

四个重要的 OS 概念：
* 线程：执行的上下文
  * 完整描述程序的状态
  * 有程序计数器，寄存器， 执行标志，栈
* 地址空间(可能有翻译机制)
  * 程序可以获取的内存地址集合，
* 进程(process): 一个正在运行的程序实例
* 双模式操作、保护

指令的 fetch/Decode/Execute 循环：<div align=center><img src="https://raw.githubusercontent.com/Haitau1996/picgo-hosting/master/img/20220113000129.png" width="40%"/></div>

## Thread of Control
* 线程是单个独立的执行上下文环境， 相当于上面的 fetch/decode/Execute loop 的虚拟化版本
* 当线程**驻留**(resident)在处理器寄存器中的时候， 它正在处理器中执行
* 驻留意味着寄存器持有该线程的根状态（上下文）
  * 包括了程序计数器(PC)寄存器 和正在执行的指令
    * PC 指向内存中要运行的下一条指令
    * 指令存放在内存中
  * 包括即将进行计算的立即数（可能是值本身或者指针）
  * 栈指针存放者栈顶的地址
  * 其他的线程则放在内存中
* 一个线程在没有加载到处理器中的时候被称为暂停(suspended)
  * 处理器的状态指向其他线程

从硬件的视角看程序的执行过程：<div align=center><img src="https://raw.githubusercontent.com/Haitau1996/picgo-hosting/master/img/20220113001607.png" width="40%"/></div>

假设我们只有一个处理器， 我们应该怎样提供多出处理器的假象：<div align=center><img src="https://raw.githubusercontent.com/Haitau1996/picgo-hosting/master/img/20220113002124.png" width="30%"/></div>
* 时分复用(multiplex in time)
* 线程实际上是虚拟的处理器<div align=center><img src="https://raw.githubusercontent.com/Haitau1996/picgo-hosting/master/img/20220113002307.png" width="40%"/></div>
* 因此线程（虚拟的处理器）中要有下面的内容：
  * PC, stack pointer
  * 寄存器
* 线程在哪里？
  * 运行在实际的内核中或者
  * 保存在一块内存中（被称为 TCB, Thread Control Block）
* 在线程之间切换的过程中， 发生了上下文切换
  * OS 正常运行
  * 将 PC,SP... 等放到 vCPU1 的 TCB 中
  * 从 vCPU2 的 TCB 中加载 PC,SP..., 跳转到 PC 的指令上
* 触发切换的机制
  * 计时器，voluntary yield, I/O ...

线程控制块（TCB）保存了线程不再运行时的寄存器内容， For now, 可以认为它们保存在 kernel 中。

## 地址空间
地址空间 👉 可访问的空间集 + 与之关联的状态。我们在地址上读写时， 很多事情都可能发生：
* 可能像正常的内存一样行为
* 可能忽略写操作
* 可能导致 I/O （memory-mapped I/O）
* 可能导致异常
* 可能和其他的程序通讯

<div align=center><img src="https://raw.githubusercontent.com/Haitau1996/picgo-hosting/master/img/20220113005310.png" width="50%"/></div>
不同类型的数据放在地址空间的不同区域：

* 程序放置于 code segment 中
* 全局变量， 静态变量，字符串字面值等放置在 Static Data segment 中
* 局部变量放在 stack segment 中
* malloc 等调用产生的变量放置在 heap 中