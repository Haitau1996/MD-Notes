# The Note is based on Sartaj Sahni's Book Mark Weiss's Book and Cheng Jie's Book on Data Structure

## Introduction
**什么是数据结构** [数据结构](https://simple.wikipedia.org/wiki/Data_structure)是计算机中存储、组织数据的方式，通常情况下精心选择的数据结构可以带来最优效率的算法，一般是抽象数据类型(ADS, Abstruct Data Type)
* 数据对象在计算机中的组织方式
    - 逻辑结构（线性结构、树、图）
    - 物理存储结构
* 数据对象必定与一系列加在其身上的操作相关联
* 完成这些操作所用的方法就是**算法**

![ADT](figure/ZJU1.1.png)<br>
**什么是算法** 
* 有限的指令集
* 接受一些输入（可能不需要输入）
* 产生输出 
* 在有限步骤后终止
* 每一条指令必须满足
    - 有充分明确的目标（没有任何歧义）
    - 计算机能处理的范围内
    - 描述不应该依赖任何计算机语言以及具体的实现手段

**什么是好的算法** ： 千万不要设计出复杂度为 $2^{n}\  or \  n!$ 的算法
* 空间复杂度
* 时间复杂度
    - 最坏情况的复杂度 $T_{worst}(n)$
    - 平均复杂度 $T_{average}(n)$

**最大子列和问题** ：
- 暴力枚举: $O(n^3)$
- 优化后的暴力枚举（相同的I不同的J只需要累加一项）： $O(n\log(n))$
- 分治算法：$O(n\log(n))$![DC-Merge](figure/ZJU1.2.png)
- 在线处理：$O(n)$,正确性不是特别明显，在线的意思是每输入一个数据就进行即时处理，在任何一个地方终止输入，算法都能正确给出当前的解

## 线性结构

### 线性表及其实现
多项式的实现：
* 顺序存储结构直接表示
* 顺序存储结构表示非零项（按照指数大小有序进行）
* 用链表结构存储非零项

**线性表** 由同类型的数据元素构成有序序列的线性结构，它可以由下面的抽象数据类型描述：<br>
![linear List](figure/ZJU2.1.png)<br>
存储实现也可以分为 **顺序存储实现**和 **链式存储实现**。
顺序存储的插入实现：从后到前，（n-1）到i的元素都要向后挪一位。链式存储很多操作都需要用遍历完成。

**广义表** 如用更复杂的链表实现多元的多项式。
![list](figure/ZJU2.2.png)<br>
* 它是线性表的推广
* 广义表的元素可以是一个单元素也可以是另一个广义表（在C中用Union实现）

**多重链表** 链表中的节点可能同时隶属于多个链（注意和双向链表区分），用途广泛，在数、图等复杂的数据结构都可以采用多重链表方式实现存储，如对于大型稀疏矩阵的存取：
![muti-llist](figure/ZJU2.3.png)<br>

### 堆栈
例：**表达式的求值** ：
* 两类对象构成 
    - 运算数，如 2、3、4
    - 运算符号，如 +、-、*、/
* 不同运算符号的优先级不同

后缀表达式：求值相对比较容易，从左往右扫描，处理运算数和运算符号，遇到运算数记住，遇到运算符号就求值。时间复杂度$O(n)$.使用Stack数据结构实现LIFO:
![stack](figure/ZJU2.4.png)<br>
同样，堆栈也可以有数组实现和链表实现。
- 数组实现：用一个[一维数组]()和一个记录[栈顶元素位置的变量]()组成,也可以用一个array存两个stack，一个向上增长，一个向下增长，两个Tag相遇就是堆栈满了
    ![stack figure](figure/ZJU2.5.png)<br>
- 链表实现：_Push_ 和 _Pop_ 都在头部进行， 头结点用一个哑节点(dummy node)

**中缀表达式求值** 

- 运算数相对顺序不变,直接输出
- 运算符号顺序发生改变
    * 需要存储"等待中"的运算符号
    * 当前运算符号与等待中最后一个运算符号进行比较
    * 遇到括号,先左括号入栈,遇到右括号把之间的运算符号符号弹出
![apppy stack](figure/ZJU2.6.png)<br>

### 队列
受操作约束的线性表, 插入和删除分别在两端,具体的抽象数据类型描述如下:
![apppy stack](figure/ZJU2.7.png)<br>

* 数组实现: 由一个一维数组和记录队列头元素位置变量 _front_ 和队尾元素变量 _rear_ 组成.
    循环队列: front==rear时候是满的还是空的如何判断? 增加额外的标记(Size或者Tag)或者仅使用n-1个元素
* 链表实现: 单向链表的前面做删除(前面插入删除都方便),后面做插入.

## 树

### 引子

查找:
    - 静态查找: 集合中记录是固定的(没有插入删除操作)
    - 动态查找: 集合中记录是动态变化的

静态查找
    1. 顺序查找(可以在`elem[0]`放置一个哨兵)
    2. 二分查找(元素必须是在数组中有序存放)
        ![判定树](figure/ZJU3.1.png)

树的定义,采用递归的办法:
![tree def](figure/ZJU3.2.png)
树的表示: 一般使用链表实现,比较好的做法是**儿子-兄弟表示法**,旋转一下就是一个二叉树(度为2的树)
![树的表示](figure/ZJU3.3.png)

### 二叉树
和一般树的区别在于, 它的**左右子树有顺序之分**.
最主要的四种遍历:
* 先序
* 中序
* 后序
* 层次遍历

#### 二叉树的存储结构
1. 顺序存储结构: 对于**完全二叉树**,可以按照从上到下, 从左到右顺序存储
    * 对于非根节点, 它的父节点序号为[i/2]
    * 节点的左孩子序号为`2*i`, 右孩子的序号是`2*i+1`
   
   对于一般的二叉树, 也可以用类似的结构, 但可能造成空间的浪费
2. 链表存储

#### 二叉树的遍历(递归)

1. 先序遍历(递归)
    * 访问根节点
    * 先序遍历其左子树
    * 先序遍历其又子树

2. 中序遍历(访问根节点调到两个递归之间)
3. 后序遍历

#### 二叉树的非递归遍历
:/ // TODO: vedio 35